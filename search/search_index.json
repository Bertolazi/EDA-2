{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sobre o curso","text":"<p>Curso de Estruturas de dados 2 da FCTE, ministrado pelo professor Bruno C\u00e9sar Ribas.</p>"},{"location":"#aluno","title":"Aluno","text":"<p>Aluno de engenharia de software da faculdade do Gama (FCTE), foi l\u00edder de telemetria na F\u00f3rmula Gama Racing onde foi respons\u00e1vel por integrar e operar o painel do carro, assegurando comunica\u00e7\u00e3o eficaz com sensores e sistemas internose, e foi aluno pesquisador, onde participou de projeto de pesquisa sobre simula\u00e7\u00e3o de ve\u00edculo h\u00edbrido flex, utilizando Unreal e Microautobox, integrando MATLAB e Simulink para comunica\u00e7\u00e3o eficaz dos sistemas.</p> <sub>Gabriel Basto</sub>"},{"location":"Prova_2/Grafos_1/","title":"Grafos","text":""},{"location":"Prova_2/Grafos_1/#tipo-abstratdos-de-dados-itens","title":"Tipo abstratdos de dados: Itens","text":"<p>Para esse primeiro momento dentro do estudo de grafos n\u00e3o nos interessa muito o que tem dentro desses itens e sim como eles se relacionam com outros itens, ent\u00e3o por exemplo em uma lista telef\u00f4nica, temos itens de uma lista telef\u00f4nica, dentro desses itens temos o nome da pessoa e o n\u00famero de telefone dessa pessoa, consideramos que o nome da pessoa \u00e9 a chave que usamos para fazer a busca dentro das rela\u00e7\u00f5es que estabelecemos, mas esses dados dentro de uma tabela hash n\u00e3o se relacionam diretamente, agora pensando em grafos pensamos realmente nas rela\u00e7\u00f5es que os itens tem entre eles, mas tudo bem, quais s\u00e3o essas rela\u00e7\u00f5es?</p> <p> Podemos pensar primeiramente em um mapa, imagine que tra\u00e7ou uma rota da sua faculdade at\u00e9 sua casa, ele vai te gerar uma rota, podemos imaginar que cada interce\u00e7\u00e3o de ruas \u00e9 um n\u00f3 do nosso grafo e a pr\u00f3pria rua \u00e9 o caminho entre esses n\u00f3s, e tem rela\u00e7\u00e3o com os outros n\u00f3es pelas ruas. O maps ent\u00e3o relcionando com os grafos, ele calcula os n\u00f3s e define o melhor caminho at\u00e9 chegar no n\u00f3 de desejo. Outro conjunto de rela\u00e7\u00f5es que podemos relacionar com grafos s\u00e3o as p\u00e1ginas webs, pensando em um site, que tem acesso a outro, cada um desses hiperlinks \u00e9 um n\u00f3 do grafo que nos leva a outro site. Outro exemplo muito legal s\u00e3o circuitos el\u00e9tricos, com os pontos de conex\u00e3o sendo n\u00f3s do nosso grafo, e os fios os caminhos que nos levam aos outros n\u00f3s. Outro caso legal seria o exemplo de rede de computadores, por exemplo, na RNP (Rede nacional de pesquisa), toda vez no esquema que vemos a sigla de um estado em um roteador temos um ponto de rede para se comunicar com outra faculdade de outro estado, cada um dessas siglas representa um n\u00f3 de rede nos estado, e a linha que os liga \u00e9 o caminho de n\u00f3 a n\u00f3, o interessante desse exemplo \u00e9 que por exemplo imagine que caia uma rota DF para SP, o grafo busca outro caminho sem ser o direto entre esses dois estados, fazendo assim, n\u00e3o dependente de uma \u00fanica rota.</p>"},{"location":"Prova_2/Grafos_1/#o-que-e-um-grafo","title":"O que \u00e9 um grafo?","text":"<p>Um conjunto de v\u00e9rtices, e um conjunto de arestas (conectam pares distindos de v\u00e9rtices), os v\u00e9rtices s\u00e3o numerados de 0 a v-1, representamso os grafos com bolinhas ligadas por linhas que conectam os mesmos (Como estamos em um teclado de computador, indicaremos sem as bolinhas). </p> <p>Grafo 1: Exemplo (4 v\u00e9rtices de 0 at\u00e9 3)</p> <p>Fonte - Autoral</p>"},{"location":"Prova_2/Grafos_1/#algumas-regras-e-conceitos-fundamentais","title":"Algumas regras e conceitos fundamentais:","text":"<ul> <li>N\u00e3o temos uma aresta que sai dela e vai para ela mesma; </li> <li>Dois v\u00e9rtices s\u00e3o adjacentes entre eles, se eles se conectam por meio de uma aresta em comum; </li> <li>Se uma aresta sai por exemplo do n\u00f3 0 para o n\u00f3 2, o caminho \u00e9 de duas vias, ou seja, do 2 eu consigo ir para o 0; </li> <li>Essa \"via de m\u00e3o dupla\" pode ser interrompida em grafos que chamamos de grafos dirigidos, com uma seta no final da aresta temos a indica\u00e7\u00e3o de um caminho s\u00f3 de ida entre um n\u00f3 e outro (veja o grafo 2 abaixo); </li> </ul> <p>Grafo 2: Grafo dirigido</p> <p>Fonte - Autoral</p> <ul> <li>Um grafo com V v\u00e9rtices tem no m\u00e1ximo [v.(v-1)]/2 arestas</li> <li>Grafo completo: Todos os v\u00e9rtices se conectam com todos os v\u00e9rtices:</li> </ul> <p>Grafo 3: Grafo completo</p> <p>Fonte - Autoral</p> <ul> <li>Caminho no grafo: \u00c9 uma sequ\u00eancia de v\u00e9rtices em que cada v\u00e9rtice sucessivo \u00e9 adjacente ao predecessor do caminho, <ul> <li>Caminho simples temos v\u00e9rtices e arestas distintas.</li> <li>Um ciclo: \u00c9 um caminho que \u00e9 simples exceto pelo primeiro e \u00faltimo v\u00e9rtice que s\u00e3o os mesmos, veja a imagem abaixo, mostrando isso.</li> </ul> </li> </ul> <p>Grafo 4: Grafo c\u00edclico</p> <p>Fonte - Autoral</p> <ul> <li> <p>Um grafo \u00e9 conexo se h\u00e1 um caminho de cada v\u00e9rtice para todo outro v\u00e9rtice no pr\u00f3prio grafo.</p> <ul> <li>Um grafo conexo exige um caminho para todos os outros v\u00e9rtices enquanto um grafo completo tem que ter uma aresta para todos os outros v\u00e9rtices.</li> <li>Um grafo que n\u00e3o \u00e9 conexo consiste em um conjunto de componentes conexas, que s\u00e3o subgrafos conexos m\u00e1ximos.</li> </ul> </li> <li> <p>Um grafo conexo ac\u00edclico \u00e9 tamb\u00e9m chamado de \u00e1rvore.</p> <ul> <li>Um conjunto de \u00e1rvores \u00e9 chamado de floresta.</li> </ul> </li> <li> <p>Como \u00e9 a nossa ADT dos grafos?</p> </li> </ul> <pre><code>typedef struct {int v; int w;}Edge; // struct respons\u00e1vel por arestas (v e w s\u00e3o os v\u00e9rtices que ela conecta).\nEdge EDGE(int, int); // Chamada de inicializa\u00e7\u00e3o da fun\u00e7\u00e3o EDGE.\ntypedef struct graph *Graph; // strfuct respons\u00e1vel pelos grafos (ainda n\u00e3o definida).\nGraph GRAPHinit(int); // Fun\u00e7\u00e3o de inicializa\u00e7\u00e3o de um grafo, o int \u00e9 a quantidade de v\u00e9rtices.\nvoid GRAPHInsertE(Graph, Edge); // Insere as arestas dentro do grafo.\nvoid GRAPHRemoveE(Graph, Edge); // Remove uma aresta dentro do grafo.\nint GRAPHEdges(Edge[], Graph G); // Contador de arestas.\nGraph GRAPHCopy(Graph); // Me devolve um grafo, duplicando um grafo.\nvoid GRAPHDestroy(Graph); // Dar um free corretamente do grafo livrando espa\u00e7o.\n</code></pre> <ul> <li>Como \u00e9 a cara da minha struct graph?<ul> <li>Uma matriz de adjac\u00eancia.<ul> <li>Uma matriz onde indicamos quem est\u00e1 conectado com quem.</li> </ul> </li> </ul> </li> </ul>"},{"location":"Prova_2/Grafos_1/#matriz-de-adjacencia","title":"Matriz de adjac\u00eancia","text":"<p>Struct graph e a fun\u00e7\u00e3o GRAPHInit (inicia o grafo com os v\u00e9rtices)</p> <pre><code>struct graph{int V, int E; int **adj;} // int V = num_vertices, int E = num_aretas, int **adj = matriz_de_adjagencia inicializada\nGraph GRAPHInit(int v){\n    Graph G = malloc(sizeof(*G));\n    G-&gt;V = v; // Recebe os v\u00e9rtices colocados\n    G-&gt;E = 0; //Ainda sem arestas\n    G-&gt;adj = MATRIZInit(V,V, 0); // Inicializa a matriz de adjac\u00eancia com 0's\n    return G;\n}\n\n</code></pre> <p></p> <p>Fun\u00e7\u00e3o MATRIZInit (inicializa a matriz de adjac\u00eancia)</p> <pre><code>int** MATRIZInit(int linhas, int colunas, int valorInicial) {\n    // Aloca mem\u00f3ria para a matriz\n    int** matriz = (int*)malloc(linhas * sizeof(int));\n    for (int i = 0; i &lt; linhas; i++) {\n        matriz[i] = (int*)malloc(colunas * sizeof(int));\n        // Inicializa a linha com o valor inicial especificado\n        for (int j = 0; j &lt; colunas; j++) {\n            matriz[i][j] = valorInicial;\n        }\n    }\n    return matriz;\n}\n</code></pre> <p>Fun\u00e7\u00e3o GRAPHInsertE (Insere uma aresta no grafo)</p> <pre><code>void GRPAHInsertE(Graph G, Edge e){ // Custo O(1)\n    int v = e.v, w = e.w; // e = struct e v e w os v\u00e9rtices que ela vai atingir\n    if(G-&gt;adj[v][w] == 0)\n        G-&gt;E++;\n    G-&gt;adj[v][w] = 1;\n    G-&gt;adj[w][v] = 1; // Se n\u00e3o for um grafo dirigido ambas atribui\u00e7\u00f5es s\u00e3o verdade\n}\n</code></pre> <p>Fun\u00e7\u00e3o GRAPHRemoveE (Remove uma aresta no grafo)</p> <pre><code>void GRAPHRemoveE(Graph G, Edge e){ // Custo O(1)\n    int v = e.v, w = e.w;\n    if(G-&gt;adj[v][w] == 1)\n        G-&gt;E--;\n    G-&gt;adj[v][w] = 0;\n    G-&gt;adj[w][v] = 0; \n}\n</code></pre> <p>Fun\u00e7\u00e3o GRAPHEdges (Contador de aresta no grafo)</p> <pre><code>int GRAPHEdges(Edge a[], Graph G){ \n    int v, w, E = 0;\n    for(v = 0; v &lt; G-&gt;v; v++)\n        for(w =v+1; w &lt; G-&gt;w; w++) // Por n\u00e3o ser um grafo dirigido n\u00e3o precisamos olhar os v\u00e9rtices menores do que estamos analizando\n            if(G-&gt;adj[v][w] = 1)\n                a[E++] = EDGE(v,w);\n    return E;\n}\n</code></pre> <ul> <li>Quando um v\u00e9rtice se liga a outro, colocamos na matriz de adjac\u00eancia o n\u00famero 1, caso contr\u00e1rio deixamos com 0.</li> <li>Se n\u00e3o for dirigido colocamos de 0 para 5 e de 5 para 0 por exemplo para indicar que podemos fazer o caminho inverso.</li> </ul> <p>Exemplo te matriz adjacente do grafo</p> 0 1 2 3 4 5 6 0 1 1 1 1 1 1 2 1 3 1 1 1 4 1 5 1 1 6 <ul> <li>Al\u00e9m das matrizes de adjac\u00eancias podemos armazenar tamb\u00e9m nas listas de adjac\u00eancias</li> </ul>"},{"location":"Prova_2/Grafos_2/","title":"Grafos","text":""},{"location":"Prova_2/Grafos_2/#lista-de-adjagencias","title":"Lista de adjag\u00eancias","text":"<p>Qualquer opera\u00e7\u00e3o para percorrer os v\u00e9rtices para proucurar as arestas vamos gastar um tempo proporcional a v^2, por isso vamos utilizar as listas adjacentes, por mais que podemos utilizar aquelas t\u00e9cnica de n\u00e3o preecisar olhar os vertices meenores da matriz, ainda temos um tempo n\u00e3o muito agrad\u00e1vel para esse tipo de problema, ainda mais com muitas arestas e v\u00e9rtices. Uma maneira diferente mas que tem sua funcionalidade, ao inv\u00e9s de termos uma matriz teremos como se fosse um grande vetor, e cada \"coisa\" dentro desse vetor seja uma lista encadeada, e quando tiver uam aresta teremos um n\u00f3 sa\u00edndo dessa posi\u00e7\u00e3o do vetor e mostrando ao qual ele est\u00e1 ligado, e se n\u00e3o estivermos falando de um grafo dirigido, o outro tamb\u00e9m ter\u00e1 seu n\u00f3 apontado para ele.</p> <p>Vamos fazer nossas opera\u00e7\u00f5es, s\u00e3o essencialmente as mesmas da matriz de adjac\u00eancia, somente tomando cuidado sabendo que estamos falando de uma fila e n\u00e3o de uma matriz, adicionaremos ent\u00e3o o n\u00f3.</p> <p>Estrutura do n\u00f3 em lista de adjac\u00eancias</p> <pre><code>typedef struct node *link\nstruct node {int v; link next;}; // Struct das arestas\nstruct graph{int V; int E; link *adj;};\nlink NEW(int v; link next){\n    link x = malloc(sizeof *x);  // Cria a aresta\n    if(x == NULL)\n        tela_azul(); // N\u00e3o encontrou , ou n\u00e3o foi criado nenhuma estrutura\n    x-&gt;v = v;   // Adiciona na struct o v\n    x-&gt;next = next; // Coloca o link para a pr\u00f3xima dentro da struct\n    return x;\n}\n\ngraph GRAPHInit(int V){  // Cria o grafo\n    int v;\n    Graph G = malloc(sizeof *G);    // Aloca a quantidade de espa\u00e7o para os v\u00e9rtices\n    G-&gt;v = V;   // Recebe os v\u00e9rtices colocados\n    G-&gt;E = 0;   // Zera as arestas\n    G-&gt;adj = malloc(V*sizeof(link)); // Cria nosso vetor de adjac\u00eancias\n    for(v = 0; v &lt; V; v++)\n        G-&gt;adj[v] = NULL; //  Criamos uma lista de adjac\u00eancias e indicamos que est\u00e3o apontando para NULL, j\u00e1 que n\u00e3o temos arestas no momento.\n    return G;\n}\n\nvoid GRAPHInsert(Graph G, Edge e){  // Insere uma aresta\n    int v = e.v, w = e.w;\n    G-&gt;adj[v] = NEW(w, G-&gt;adj[v]); // Inserimos no in\u00edcio da lista simplesmente por ser mais barato.\n    G-&gt;adj[v] = NEW(v, G-&gt;adj[w]);\n    G-&gt;E++;\n}\n\nint GRAPHEdges(Edge a[], Graph G){ // Salva as arestas em um vetor e retorna a quantidade\n    int v, E=0;                    // Com a chamda a[], se tem que ja foi alocado o vetor do tamanho correto previamente\n    for(v = 0; v &lt; G-&gt;v; v++)\n        for(t = G-&gt;adj[v]; t != NULL; t = t-&gt;next)\n            if(v &lt; t-&gt; v)\n                a[E++] = EDGE(v, t-&gt;v);\n    return E;\n}\n</code></pre>"},{"location":"Prova_2/Grafos_2/#que-metodo-devo-usar","title":"Que m\u00e9todo devo usar?","text":"<p>Compara\u00e7\u00e3o entre vetor de arestas, matriz de adjac\u00eancia e lista de adjac\u00eancia.</p> Vetor de arestas Matriz de adjac\u00eancias Lista de adjac\u00eancias Espa\u00e7o E (quantidade de arestas) V^2 (v\u00e9rtices ao quadrado) V+E Pre\u00e7o para inicializar 1 V^2 V Copiar E V^2 E Destruir 1 V (free em cada v\u00e9rtice) E (Para cada v\u00e9rtice percorre todas as arestas) Inserir arestas 1 1 (L\u00ea o v e o w, e coloca valor 1 na matriz) 1 (Alocar 2 n\u00f3s um para v e um para w, adicionando sempre no in\u00edcio da lista encadeada) Encontrar e remover uma aresta E 1 (Pergunta se v e w \u00e9 1, e se quiser \u00e9 s\u00f3 remover) V (O m\u00e1ximo de arestas que um v\u00e9rtice pode ter \u00e9 exatamente a quantidade de v\u00e9rtices total) V \u00e9 isolado? (Se n\u00e3o tiver nenhuma aresta conectada ao v\u00e9rtice) E (Anda em todas as arestas buscando uma rela\u00e7\u00e3o com outro V) V (percorre toda coluna do v\u00e9rtice para ver se todos os \u00edndices est\u00e3o marcados como 0) 1 (Basta perguntar no \u00edndice para o V se \u00e9 NULL) Caminho de U para V E.log(V) V^2 (Percorrer todas as arestas de U at\u00e9 chegar a v, logo se v\u00ea todas as conex\u00f5es da matriz) V+E"},{"location":"Prova_2/Grafos_2/#busca-em-profundidade-dfs","title":"Busca em profundidade (DFS)","text":"<p>Se eu quero passar por todos os v\u00e9rtices passando pleo menor caminho poss\u00edvel, como posso fazer isso? A busca em profundidade \u00e9 um \u00f3tima tentativa para achar labirintos. Imagine um corredor com 3 sa\u00eddas vamos tomar uma decis\u00e3o de onde ir, para isso vamos usar as pilhas.</p> <p>Busca em profundidade</p> <pre><code>int pre[V];\n\nvoid dfsR(Graph G, Edge e){\n    int t, w = e.w; \n    pre[w]=count++; // Mant\u00e9m a ordem de qual visitamos primeiro, e mostra quais v\u00e9rtices j\u00e1 foram visitados.\n    for(t = 0; t &lt; G-&gt;V, t++)\n        if(G-&gt;adj[w][t] != 0)\n            if(pre[t] == -1) // Para quando todos estiverem com valor diferente de -1, ou a fun\u00e7\u00e3o acaba e passamos por todos os v\u00e9rtices conexos por w\n                dfsR(G, EDGE(w, t));\n}\n\nint main(){\n    GRAPHInit(V);\n    for(int V = 0; V &lt; G-&gt;V; V++)\n        pre[v] = -1;\n    dfsR(G, EDGE(0, 0));\n}\n</code></pre> <p></p> <p>Se fizermos algo parecido com o c\u00f3digo de cima no grafo de baixo, come\u00e7ando do dfsR(G, EDGE(0,0)), ele percorrer\u00e1 todos de 0 at\u00e9 0 passando por todos os caminhos, mas perceba que nenhuma aresta passa pelo 0 e qualquer outro v\u00e9rtice e chega em 8 ou 9, logo ele n\u00e3o perocrrer\u00e1 em momento nenhum esses v\u00e9rtices.</p> <p>Se diferentemente executarmos a fun\u00e7\u00e3o dfsR(G, EDGE(8,8)), ele executar\u00e1 somente um caminho de 8-&gt;9, tendo em vista que s\u00f3 tem esse caminho, e n\u00f3s nesse modelo s\u00f3 contabilizamos a ida, j\u00e1 que a ida e a vinda \u00e9 a mesma aresta.</p> <p>Grafo 5: Grafo exemplo</p> <p>Fonte - Autoral</p>"},{"location":"Prova_2/Grafos_3/","title":"Grafos","text":""},{"location":"Prova_2/Grafos_3/#resumo-de-grafos","title":"Resumo de grafos","text":"<p>O importante \u00e9 definir a rela\u00e7\u00e3o entre os n\u00f3s, ent\u00e3o temos um conjunto de v\u00e9rtices que t\u00eam rela\u00e7\u00e3o com outro conjunto de v\u00e9rtices, tudo o que implementamos \u00e9 para fazer perguntas de como essas rela\u00e7\u00f5es se comportam ou se relacionam, essa conex\u00e3o se da por meio de arestas. Por mais que a estrutura gr\u00e1fica dos grafos seja simples com as bolinhas representando os v\u00e9rtices, e as linhas representando as arestas, quando tratamos essa estrutura na an\u00e1lise de dados essa estrutura j\u00e1 n\u00e3o \u00e9 mais t\u00e3o simples quanto aparenta ser.</p> <p>Podemos representar o grafo de duas formas:</p> <ul> <li>Matriz de adjac\u00eancia: N\u00famero 1 quando tem rela\u00e7\u00e3o e 0 quando n\u00e3o tem rela\u00e7\u00e3o;</li> <li>Lista de adjac\u00eancia: Colocamos no \u00edndice do vetor um link para os outros v\u00e9rtices com que eles est\u00e3o ligados pela arestas;</li> </ul>"},{"location":"Prova_2/Grafos_3/#componentes-conexas","title":"Componentes conexas","text":"<p>Como podemos identificar as componentes conexas usando busca em profundidade? Bem, para isso vamos pegar como exemplo o grafo abaixo j\u00e1 msotrado na aula passada, veja abaixo:</p> <p>Grafo 5: Grafo exemplo</p> <p>Fonte - Autoral</p> <p>Como podemos ver no grafo acima temos duas componentes conexas: Todo grupo unido com o 0 de um lado, e do outro o 9 junto do 8. Como podemos fazer isso? Bom mas antes de fazer isso vamos fazer uma fun\u00e7\u00e3o gen\u00e9rica para fazer uma busca geral no gr\u00e1fico, contando quantos v\u00e9rtices eu visitei</p> <p>Fun\u00e7\u00e3o GRAPHSearch para lista de adjac\u00eancias</p> <pre><code>static int count, pre[maxV];\nvoid GRAPHSearch(Graph G){  // Com esse algoritmo o sistema computa a sa\u00edda da componente conexa e vai para a pr\u00f3xima\n    int v; // V\u00e9rtices que vou visitar\n    int conexos = 0;\n    count = 0;\n    for(v = 0; G-&gt;V; v++)\n        pre[v]=-1;\n    for(v = 0; G-&gt;V; v++){ // Executa todos de 0 a 7, na segunda intera\u00e7\u00e3o ele faz a intera\u00e7\u00e3o de 8 e 9\n        if(pre[v] == -1){ // Se for != de -1 ele nem entra na DSF\n            dsfR(G, EDGE(v, v));\n            conexos++;\n        }\n    }\n}\n</code></pre> <p>dfsR para lista de ajac\u00eancia</p> <pre><code>void dfsR(Graph G, Edge e){\n    int t, w = e.w;\n    link l;\n    pre[w] = count++;\n    for(l=G-&gt;adj[w]; l != NULL; l = l-&gt;next){\n        t = l-&gt;v;\n        if(pre[t] == -1)    \n            dfsR(G, EDGE(w, t));\n    }\n}\n</code></pre> <p>Fun\u00e7\u00e3o GRAPHSearch para lista de adjac\u00eancias</p> <pre><code>static int count, pre[maxV];\nvoid GRAPHSearch(Graph G){  \n    int v; \n    int conexos = 0;\n    count = 0;\n    for(v = 0; G-&gt;V; v++)\n        pre[v]=-1;\n    for(v = 0; G-&gt;V; v++){ \n        if(pre[v] == -1){ \n            dsfRM(G, EDGE(v, v)); // \u00danica mudan\u00e7a para o GRAPHSearch antigo. \u00c9 chamar a dsfRM, ou seja a dsf da matriz de adjac\u00eancia\n            conexos++;\n        }\n    }\n}\n</code></pre> <p>dfsRM para matriz de ajac\u00eancia</p> <pre><code>void dfsRM(Graph G, Edge e) {\n    int w = e.w;\n    pre[w] = count++;\n    for (int t = 0; t &lt; G-&gt;V; t++) {\n        if (G-&gt;adj[w][t] == 1 &amp;&amp; pre[t] == -1) {\n            dfsR(G, EDGE(w, t));\n        }\n    }\n}\n</code></pre>"},{"location":"Prova_2/Grafos_3/#execucao-manual","title":"Execu\u00e7\u00e3o manual","text":""},{"location":"Prova_2/Grafos_4/","title":"Grafos","text":""},{"location":"Prova_2/Grafos_4/#busca-em-largura-bfs","title":"Busca em largura (BFS)","text":"<p>O BFS \u00e9 prefer\u00edvel quando se busca encontrar o caminho mais curto entre dois n\u00f3s em um grafo n\u00e3o ponderado (onde todas as arestas t\u00eam o mesmo peso), enquanto o DFS \u00e9 mais eficiente quando se busca explorar um grafo em profundidade, ou quando se deseja encontrar solu\u00e7\u00f5es que podem estar distantes da fonte.</p> <p>Algoritmo da BFS</p> <pre><code>void bfs(Graph G, Edge e){\n    int v, w;\n    Queueput(e);\n    pre[e.w] = count++;\n    while(!Queueempty()){\n        e = Queueget();\n        w = e.w;\n        for(l=G-&gt;adj[w]; l != NULL; l = l-&gt;next){\n            t = l-&gt;v;\n            if(pre[t] == -1){\n                Queueput(EDGE(w, t));\n                pre[t] = count++;\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"Prova_2/Grafos_4/#execucao-manual","title":"Execu\u00e7\u00e3o manual","text":""},{"location":"Prova_2/Grafos_5/","title":"Grafos","text":""},{"location":"Prova_2/Grafos_5/#grafos-dirigido","title":"Grafos dirigido","text":"<ul> <li>A ideia dos grafos dirigidos \u00e9 que agora as arestas dos grafos agora possuem dire\u00e7\u00f5es, diferente de alguns de nossos grafos mostrados anteriormente onde dentro das matriz de adjac\u00eancias ou da lista de adjac\u00eancias sempre que A apontava para B, ou vet[A][B] \u00e9 verdade, o nosso B apontava para A e vet[B][A] tamb\u00e9m era verdade. No caso do grafo dirigido temos uma via de m\u00e3o \u00fanica onde se A aponta para B, B n\u00e3o aponta para A por regra.</li> </ul> <p>Grafo 5: Grafo dirigido exemplo</p> <p>Fonte - Autoral</p> <p></p> <p>Agora vamos observar abaixo a lista encadeada abaixo onde podemos ver como \u00e9 a forma\u00e7\u00e3o de uma lista encadeada para essa situa\u00e7\u00e3o de um d\u00edgrafo. N\u00e3o h\u00e1 uma grande diferen\u00e7a para com a lista encadeada para um grafo tradicional, sua \u00fanica difren\u00e7a \u00e9 que por regra se A aponta para B, B N\u00e3o aponta para A, mas como \u00e9 poss\u00edvel analisar a rela\u00e7\u00e3o dos v\u00e9rtices 2 e 3, eles apontam um para o outro, mas diferente de um grafo normal isso n\u00e3o \u00e9 uma regra.</p> <p></p> <p>Imagem 4: Lista encadeada de grafo dirigido (exemplo acima)</p> <p>Fonte - Autoral</p> <ul> <li> <p>O m\u00e1ximo de arestas em um grafo dirigido sem la\u00e7os \u00e9 v(v-1).</p> </li> <li> <p>Grafo dirigido (ou d\u00edgrafo): \u00c9 um conjunto de v\u00e9rtices e um conjunto de arestas dirigidas que conectam um par de v\u00e9rtices (Sem arestas duplicadas). Dizemos que essa aresta vai de um primeiro v\u00e9rtice para o seu segundo v\u00e9rtice.</p> </li> <li> <p>Edge{int v, int w}, v \u00e9 o primeiro e w \u00e9 o segundo, ou seja ele vai de v para w (novamente enfatizando que n\u00e3o obrigat\u00f3riamente esse w volta para v).</p> </li> <li> <p>Caminho dirigido: Em um grafo dirigido a lista de v\u00e9rtices no qual existe uma resta dirigida conectando cada v\u00e9rtice da lista a seu sucessor. Dizemos de um v\u00e9rtice t \u00e9 alcan\u00e7\u00e1vel de um v\u00e9rtice s se existe um caminho dirigido de s a t.</p> </li> <li> <p>Quantidade de arestas em um grafo n\u00e3o dirigido \u00e9 [v(v-1)]/2, j\u00e1 em um grafo dirigido temos v(v-1).</p> </li> </ul> <p>Como inverter as arestas de um grafo dirigido com listas encadeadas?&gt;</p> <pre><code>Graph GRAPHReverse(Graph G){\n    int v;\n    link t;\n    Graph R = GRAPHInit(G-&gt;v); // Iniciamos um segundo Grafo com a fun\u00e7\u00e3o de inicializar o grafo com a mesma quantidade de v\u00e9rtices\n    for (v=0; v &lt; G-&gt;V; v++) // Percorremos os v\u00e9rtices\n        for(t=G-&gt;adj[v]; t != NULL; t=t-&gt;next) // Para cada aresta t, conectada a partir de V\n            GRAPHinsert(R, EDGE(t-&gt;v, v)); // Agora inserimos cada aresta apoontada de forma invertida\n    return R;\n}\n</code></pre> <p>Como inverter as arestas de um grafo dirigido com matriz de adjac\u00eacias?&gt;</p> <pre><code>Graph GRAPHReverse(Graph G) {\n    int i, j;\n    Graph R = GRAPHInit(G-&gt;V); // Cria grafo com mesma quantidade de v\u00e9rtices\n    for (i = 0; i &lt; G-&gt;V; i++) {\n        for (j = 0; j &lt; G-&gt;V; j++) {\n            if (G-&gt;adj[i][j] == 1) { // Existe uma aresta de i para j\n                R-&gt;adj[j][i] = 1;   // No grafo reverso, vai de j para i\n            }\n        }\n    }\n    return R;\n}\n</code></pre>"},{"location":"Prova_2/Grafos_5/#dag","title":"DAG","text":"<ul> <li>Grafo dirigido ac\u00edclico (DAG - Directed aciclic graph): Grafo dirigido que n\u00e3o possiu ciclos (\u00c1rvores). <ul> <li>Quando eu digo que temos um DAG quero dizer que um v\u00e9rtice n\u00e3o volta para um v\u00e9rtice que est\u00e1 acima na ordem topol\u00f3gica. Veja o exemplo abaixo:</li> </ul> </li> </ul> <p>Grafo 6: Grafo dirigido ac\u00edclico</p> <p>Fonte - Autoral</p>"},{"location":"Prova_2/Grafos_5/#grafo-dirigido-fortemente-conexo","title":"Grafo dirigido fortemente conexo","text":"<ul> <li>Grafo dirigido fortemente conexo: Acontece se todos os v\u00e9rtices s\u00e3o alcan\u00e7\u00e1veis a partir de todos os v\u00e9rices. </li> </ul> <p>Grafo 7: Grafo dirigido fortemente conexo</p> <p>Fonte - Autoral</p>"},{"location":"Prova_2/Grafos_5/#alcancabilidade-e-fecho-transitivo","title":"Alcan\u00e7abilidade e fecho transitivo","text":"<ul> <li>Fecho transitivo de um grafo dirigido \u00e9 um grafo dirigido com um mesmo conjunto de v\u00e9rtices, mas com uma aresta de s a t no fecho transitico, se e somente se existe um caminho dirigido de s a t no grafo dirigido</li> </ul> <p>Grafo 8: Grafo dirigido exemplo p\u00e1ra fexho transitivo</p> <p>Fonte - Autoral</p> <p>O fecho transitivo desse grafo segue abaixo:</p> <p>Imagem 5: Exemplo de fecho transitivo</p> <p>Fonte - Autoral</p> <p>Resumindo ent\u00e3o o fecho transitivo seria um grafo que n\u00e3o conecta somente aos adjacentes apontados, mas tamb\u00e9m fa\u00e7a uma conex\u00e3o direta entre o ponto de onde ele sai e o v\u00e9rtice que ele aponta leva ele, ou seja se A-&gt;B e B-&gt;C, colocamos que o v\u00e9rtice A-&gt;B, A-&gt;C e B-&gt;C.</p>"},{"location":"Prova_2/Grafos_5/#algoritmo-floyd-warshal","title":"Algoritmo Floyd Warshal","text":"<ul> <li>Complexidade alta: Tende a n\u00b3, mas resolve todos os fechos transitivos de uma vez s\u00f3.</li> </ul> <p>Algoritmo Floyd Warshal para matriz de ajac\u00eancias GRAPHtc</p> <pre><code>void GRAPHtc(GRAPH G){\n    int i, s, t;\n    G-&gt;tc = MATRIZint(G-&gt;V, G-&gt;V, 0); // Teve que ser modificado na estrutura grafo, somente adicionar um ponteiro de ponteiro chamado tc\n    for(s = 0; s &lt; G-&gt;V; s++)\n        for(t = 0; t &lt; G-&gt;V; t++)\n            G-&gt;tc[s][t] = G-&gt;adj[s][t]; // Isso para cima \u00e9 para percorrer os v\u00e9rtices para copiar as conex\u00f5es que j\u00e1 temos no grafo\n    for(s = 0; s &lt; G-&gt;V; s++)\n        G-&gt;tc[s][s] = 1; // Indicando que ele alcan\u00e7a ele mesmo\n    for(i = 0;. i &lt; G-&gt;V; i++)\n        for(s = 0; s &lt; G-&gt;V; s++)\n            if(G-&gt;tc[s][i] == 1)\n                for(t = 0; t &lt; G-&gt;V; t++)\n                    if(G-&gt;tc[i][t] == 1)\n                        G-&gt;tc[s][t] = 1;\n}\n</code></pre> <p>A chamada dessa fun\u00e7\u00e3o, ent\u00e3o:</p> <pre><code>int GRAPHreach(Graph G, int s, int t){\n    return G-&gt;tc[s][t];\n}\n</code></pre> <p>Nesse caso \u00e9 melhor utilizar a matriz de adjac\u00eancias, j\u00e1 que esse grafo agora vai possuir muitas arestas, ou seja, a economia de mem\u00f3ria que a gente ia ter com a nossa lista de adjac\u00eancias, j\u00e1 n\u00e3o \u00e9 mais t\u00e3o vantajosa em rela\u00e7\u00e3o a matriz de adjac\u00eancias, e pior a nossa pergunta se nosso v\u00e9rtice s, tem conex\u00e3o com com t ia ter custo O(V), porque teria que percorrer todos os v\u00e9rtices, com quem o v\u00e9rtice s tem conex\u00e3o, mas o t pode n\u00e3o estar, ent\u00e3o precisamos de v-1, para encontrar, j\u00e1 com matriz de adjac\u00eancias a consulta para isso tem custo O(1).</p> <p></p> <p>O custo desse algoritmo \u00e9 n\u00b3, tornando ele bem caro para os algoritmos que vemos na mat\u00e9ria.</p>"},{"location":"Prova_2/Grafos_5/#resumo-dos-algoritmos","title":"Resumo dos algoritmos","text":"<p>A fun\u00e7\u00e3o GRAPHtc \u00e9 respons\u00e1vel por preparar a estrutura de dados (G-&gt;tc), e a fun\u00e7\u00e3o GRAPHreach \u00e9 usada para consultar rapidamente essa estrutura, respondendo se um v\u00e9rtice alcan\u00e7a outro no grafo. Essa separa\u00e7\u00e3o \u00e9 comum em algoritmos que fazem um pr\u00e9-processamento caro, mas permitem consultas r\u00e1pidas depois.</p>"},{"location":"Prova_2/Grafos_5/#execucao-manual","title":"Execu\u00e7\u00e3o manual","text":""},{"location":"Prova_3/Arvore_geradora_1/","title":"\u00c1rvore geradora","text":""},{"location":"Prova_3/Arvore_geradora_1/#1-definicao-de-arvore-geradora","title":"1. Defini\u00e7\u00e3o de \u00c1rvore Geradora","text":"<p>Uma \u00e1rvore geradora (spanning tree) de um grafo n\u00e3o-dirigido e conexo \u00e9 um subgrafo que:</p> <ul> <li>Inclui todos os v\u00e9rtices do grafo original.</li> <li>\u00c9 conexo e sem ciclos (ou seja, uma \u00e1rvore).</li> <li>Possui exatamente V - 1 arestas, onde V \u00e9 o n\u00famero de v\u00e9rtices.</li> </ul> <p>Todo grafo n\u00e3o-dirigido e conexo possui pelo menos uma \u00e1rvore geradora.</p>"},{"location":"Prova_3/Arvore_geradora_1/#2-como-obter-uma-arvore-geradora","title":"2. Como Obter uma \u00c1rvore Geradora","text":"<ul> <li>Tanto a busca em profundidade (DFS) quanto a busca em largura (BFS) podem gerar uma \u00e1rvore geradora.</li> <li>Ambas constroem uma \u00e1rvore radicada, conectando todos os v\u00e9rtices acess\u00edveis a partir de um v\u00e9rtice inicial.</li> <li>As arestas exploradas formam uma \u00e1rvore geradora.</li> </ul>"},{"location":"Prova_3/Arvore_geradora_1/#3-cortes-em-grafos","title":"3. Cortes em Grafos","text":"<ul> <li>Um corte \u00e9 o conjunto de arestas que conecta um subconjunto de v\u00e9rtices ( X ) ao seu complemento ( \\overline{X} ).</li> <li>O leque de ( X ) \u00e9 esse conjunto de arestas.</li> <li>Se o corte \u00e9 vazio, o grafo \u00e9 desconexo.</li> </ul>"},{"location":"Prova_3/Arvore_geradora_1/#exemplo","title":"Exemplo:","text":"<p>Para o grafo com arestas = 0-1, 0-2, 2-1, 3-5, 4-5:</p> <p>O corte entre <code>{0}</code> e <code>{1,2,3,4,5}</code> \u00e9 <code>{0-1, 0-2}</code>.</p>"},{"location":"Prova_3/Arvore_geradora_1/#4-propriedades-de-substituicao-de-arestas","title":"4. Propriedades de Substitui\u00e7\u00e3o de Arestas","text":"<p>Essas propriedades s\u00e3o fundamentais para os algoritmos de MST (\u00e1rvore geradora m\u00ednima).</p>"},{"location":"Prova_3/Arvore_geradora_1/#propriedade-dos-circuitos-insereremove","title":"Propriedade dos Circuitos (Insere\u2013Remove)","text":"<p>Seja ( T ) uma \u00e1rvore geradora e ( e \\notin T ). Ent\u00e3o:</p> <ul> <li>O grafo ( T + e ) cont\u00e9m um \u00fanico circuito.</li> <li>Remover qualquer aresta ( t ) desse circuito produz outra \u00e1rvore geradora:  T + e - t \u2192 tamb\u00e9m \u00e9 uma \u00e1rvore geradora</li> </ul> <p>Esse circuito \u00e9 chamado circuito fundamental de e em rela\u00e7\u00e3o a T.</p>"},{"location":"Prova_3/Arvore_geradora_1/#propriedade-dos-cortes-removeinsere","title":"Propriedade dos Cortes (Remove\u2013Insere)","text":"<p>Seja ( t \\in T ). A remo\u00e7\u00e3o de ( t ) decomp\u00f5e ( T ) em duas componentes conexas.</p> <ul> <li>O corte fundamental de t \u00e9 o conjunto de arestas que conecta essas duas partes.</li> <li>Para qualquer ( e ) nesse corte: T - t + e \u2192 tamb\u00e9m \u00e9 uma \u00e1rvore geradora</li> </ul>"},{"location":"Prova_3/Arvore_geradora_1/#circuitos-vs-cortes","title":"Circuitos vs. Cortes","text":"<p>Existe uma rela\u00e7\u00e3o direta:</p> <p>t est\u00e1 no circuito fundamental de e \u27fa e est\u00e1 no corte fundamental de t</p>"},{"location":"Prova_3/Arvore_geradora_1/#5-exercicios-propostos-do-site","title":"5. Exerc\u00edcios Propostos (do site)","text":"<ul> <li>Encontrar \u00e1rvores geradoras a partir de conjuntos de arestas.</li> <li>Usar DFS e BFS para gerar \u00e1rvores.</li> <li>Calcular cortes e circuitos fundamentais.</li> <li>Implementar <code>CheckMST()</code> para verificar se um vetor de pais representa uma \u00e1rvore geradora.</li> </ul>"},{"location":"Prova_3/Arvore_geradora_1/#conceitos-resumidos","title":"Conceitos Resumidos","text":"Conceito Defini\u00e7\u00e3o \u00c1rvore Geradora Subgrafo conexo, sem ciclos, com V-1 arestas Leque de X Arestas entre X e seu complemento ( \\overline{X} ) Corte Leque de um subconjunto n\u00e3o-trivial de v\u00e9rtices Circuito Fundamental \u00danico circuito criado ao adicionar uma aresta a uma \u00e1rvore geradora Corte Fundamental Conjunto de arestas conectando as partes ap\u00f3s remover aresta de T"},{"location":"Prova_3/Arvore_geradora_1/#referencia","title":"Refer\u00eancia","text":"<p>Fonte: Paulo Feofiloff - IME USP</p>"},{"location":"Prova_3/Arvore_geradora_2/","title":"\u00c1rvore Geradora Barata (MST)","text":""},{"location":"Prova_3/Arvore_geradora_2/#1-o-problema-da-arvore-geradora-de-custo-minimo-mst","title":"1. O Problema da \u00c1rvore Geradora de Custo M\u00ednimo (MST)","text":"<p>Dado um grafo n\u00e3o-dirigido, conexo e com arestas ponderadas, a \u00e1rvore geradora m\u00ednima (MST) \u00e9 uma \u00e1rvore geradora que:</p> <ul> <li>Cont\u00e9m todos os v\u00e9rtices do grafo;</li> <li>\u00c9 ac\u00edclica e conexa;</li> <li>Possui o menor custo total poss\u00edvel (soma dos pesos das arestas).</li> </ul> <p>\u2139Todas as MSTs t\u00eam o mesmo custo, mas podem n\u00e3o ser \u00fanicas.</p>"},{"location":"Prova_3/Arvore_geradora_2/#2-propriedades-fundamentais","title":"2. Propriedades Fundamentais","text":""},{"location":"Prova_3/Arvore_geradora_2/#circuito-fundamental-e-otimalidade","title":"Circuito Fundamental e Otimalidade","text":"<ul> <li>Seja ( T ) uma MST e ( e \\notin T ).</li> <li>Adicionar ( e ) forma um circuito.</li> <li>Se uma aresta ( t ) do circuito tem peso maior que ( e ), ent\u00e3o ( T + e - t ) \u00e9 uma MST mais barata, o que contradiz ( T ) ser \u00f3tima.</li> </ul> <p>Conclus\u00e3o: No circuito fundamental de qualquer ( e \\notin T ), todas as arestas ( t \\in T ) t\u00eam peso menor ou igual ao de ( e ).</p>"},{"location":"Prova_3/Arvore_geradora_2/#corte-fundamental-e-otimalidade","title":"Corte Fundamental e Otimalidade","text":"<ul> <li>Remover uma aresta ( t \\in T ) separa ( T ) em dois subconjuntos.</li> <li>O corte fundamental \u00e9 o conjunto de arestas entre esses subconjuntos.</li> <li>Nenhuma aresta ( e \\notin T ) nesse corte pode ser mais barata que ( t ), sen\u00e3o ( T - t + e ) teria custo menor.</li> </ul>"},{"location":"Prova_3/Arvore_geradora_2/#3-algoritmos-para-computar-mst","title":"3. Algoritmos para Computar MST","text":""},{"location":"Prova_3/Arvore_geradora_2/#algoritmo-de-prim-jarnik","title":"Algoritmo de Prim (Jarnik)","text":"<ul> <li>Cresce a MST a partir de um \u00fanico v\u00e9rtice.</li> <li>A cada passo, adiciona a aresta de menor peso que conecta a \u00e1rvore a um novo v\u00e9rtice.</li> <li> <p>Usa estrutura de dados como fila de prioridade (heap) para efici\u00eancia.</p> </li> <li> <p>Invariantes:</p> <ul> <li>Arestas em <code>mst</code> formam uma \u00e1rvore.</li> <li>A fila <code>pq</code> cont\u00e9m as menores arestas que cruzam a fronteira da MST parcial.</li> </ul> </li> </ul>"},{"location":"Prova_3/Arvore_geradora_2/#algoritmo-de-kruskal","title":"Algoritmo de Kruskal","text":"<ul> <li>Ordena todas as arestas por peso.</li> <li>Adiciona as arestas mais baratas que n\u00e3o formam ciclos.</li> <li> <p>Usa estrutura Union-Find (UF) para manter componentes conexas.</p> </li> <li> <p>Invariantes:</p> <ul> <li><code>mst</code> n\u00e3o cont\u00e9m ciclos.</li> <li>Quando cont\u00e9m ( V - 1 ) arestas, ela \u00e9 uma MST.</li> </ul> </li> </ul>"},{"location":"Prova_3/Arvore_geradora_2/#4-codigo-em-c-algoritmo-de-kruskal","title":"4. C\u00f3digo em C \u2014 Algoritmo de Kruskal","text":"<pre><code>int UFfind(int v) {\n   while (v != id[v]) v = id[v];\n   return v;\n}\n\nvoid UFunion(int v, int w) {\n   int i = UFfind(v), j = UFfind(w);\n   if (i == j) return;\n   if (sz[i] &lt; sz[j]) {\n      id[i] = j; sz[j] += sz[i];\n   } else {\n      id[j] = i; sz[i] += sz[j];\n   }\n}\n</code></pre>"},{"location":"Prova_3/Arvore_geradora_3/","title":"Algoritmo de Prim \u2014 \u00c1rvores Geradoras de Custo M\u00ednimo (MST)","text":""},{"location":"Prova_3/Arvore_geradora_3/#1-objetivo","title":"1. Objetivo","text":"<p>Construir uma \u00c1rvore Geradora de Custo M\u00ednimo (MST) em um grafo n\u00e3o-dirigido, conexo e ponderado, utilizando o algoritmo de Prim (tamb\u00e9m conhecido como algoritmo de Jarnik).</p>"},{"location":"Prova_3/Arvore_geradora_3/#2-ideia-do-algoritmo","title":"2. Ideia do Algoritmo","text":"<ul> <li>Come\u00e7a com um v\u00e9rtice arbitr\u00e1rio ( s ) e constr\u00f3i a MST incrementalmente.</li> <li>Em cada passo, adiciona a menor aresta que conecta a \u00e1rvore constru\u00edda a um v\u00e9rtice fora dela.</li> </ul>"},{"location":"Prova_3/Arvore_geradora_3/#3-variaveis-usadas","title":"3. Vari\u00e1veis Usadas","text":"<ul> <li><code>pai[v]</code>: pai do v\u00e9rtice <code>v</code> na MST.</li> <li><code>dist[v]</code>: menor peso de uma aresta que conecta <code>v</code> \u00e0 MST.</li> <li><code>franja</code>: conjunto de v\u00e9rtices fora da MST mas adjacentes a ela.</li> <li><code>heap</code>: fila de prioridade que organiza os v\u00e9rtices da franja por <code>dist[v]</code>.</li> </ul>"},{"location":"Prova_3/Arvore_geradora_3/#4-invariantes-do-algoritmo","title":"4. Invariantes do Algoritmo","text":"<ul> <li>Os v\u00e9rtices na MST t\u00eam seus <code>pai[v]</code> definidos.</li> <li>Os v\u00e9rtices na franja t\u00eam <code>dist[v]</code> correspondendo \u00e0 menor aresta conectando \u00e0 MST.</li> <li>O heap cont\u00e9m exatamente os v\u00e9rtices da franja.</li> </ul>"},{"location":"Prova_3/Arvore_geradora_3/#5-etapas-do-algoritmo","title":"5. Etapas do Algoritmo","text":"<ol> <li>Inicialize todos os v\u00e9rtices com <code>dist[v] = \u221e</code> e <code>pai[v] = -1</code>.</li> <li>Escolha um v\u00e9rtice <code>s</code> inicial e defina <code>dist[s] = 0</code>.</li> <li>Adicione <code>s</code> ao heap.</li> <li>Enquanto o heap n\u00e3o estiver vazio:</li> <li>Remova o v\u00e9rtice <code>v</code> com menor <code>dist[v]</code> do heap.</li> <li>Para cada vizinho <code>w</code> de <code>v</code>:<ul> <li>Se <code>w</code> n\u00e3o est\u00e1 na MST e <code>peso(v,w) &lt; dist[w]</code>:</li> <li>Atualize <code>dist[w]</code> e <code>pai[w]</code>.</li> </ul> </li> </ol>"},{"location":"Prova_3/Arvore_geradora_3/#6-codigo-pseudo-c","title":"6. C\u00f3digo (pseudo-C)","text":"<pre><code>void primMST(Graph G, int s) {\n    for (v = 0; v &lt; G-&gt;V; v++) {\n        dist[v] = INF;\n        pai[v] = -1;\n    }\n    dist[s] = 0;\n    PQinsert(s);\n\n    while (!PQempty()) {\n        int v = PQdelmin();\n        for (link a = G-&gt;adj[v]; a != NULL; a = a-&gt;next) {\n            int w = a-&gt;w;\n            if (pai[w] == -1 || a-&gt;peso &lt; dist[w]) {\n                dist[w] = a-&gt;peso;\n                pai[w] = v;\n                PQdec(w, dist[w]);\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"Prova_3/Arvore_geradora_3/#7-complexidade","title":"7. Complexidade","text":"<ul> <li>Usando heap bin\u00e1rio, a complexidade \u00e9 O((V+E)log\u2061V)O((V+E)logV).</li> <li>Mais eficiente que algoritmos de for\u00e7a bruta para grafos esparsos.</li> </ul>"},{"location":"Prova_3/Arvore_geradora_3/#8-exemplos-e-testes","title":"8. Exemplos e Testes","text":"<ul> <li>\u00c9 poss\u00edvel acompanhar o crescimento da MST atrav\u00e9s da sequ\u00eancia de v\u00e9rtices removidos do heap.</li> <li>A estrutura final de pai[v] forma a MST.</li> </ul>"},{"location":"Prova_3/Arvore_geradora_4/","title":"Algoritmo de Kruskal \u2014 \u00c1rvores Geradoras M\u00ednimas (MST)","text":""},{"location":"Prova_3/Arvore_geradora_4/#1-objetivo","title":"1. Objetivo","text":"<p>Construir uma \u00c1rvore Geradora de Custo M\u00ednimo (MST) de um grafo n\u00e3o-dirigido, conexo e ponderado, usando o algoritmo de Kruskal.</p>"},{"location":"Prova_3/Arvore_geradora_4/#2-ideia-do-algoritmo","title":"2. Ideia do Algoritmo","text":"<ul> <li>Ordena todas as arestas do grafo por peso crescente.</li> <li>Inicializa a MST como vazia.</li> <li>Para cada aresta na ordem:</li> <li>Adiciona a aresta se ela n\u00e3o forma ciclo com as arestas j\u00e1 adicionadas.</li> </ul> <p>A ideia \u00e9 manter uma floresta crescente que se funde progressivamente em uma \u00e1rvore.</p>"},{"location":"Prova_3/Arvore_geradora_4/#3-estrutura-de-dados-utilizada","title":"3. Estrutura de Dados Utilizada","text":""},{"location":"Prova_3/Arvore_geradora_4/#union-find-uf","title":"Union-Find (UF)","text":"<p>Usada para: - Representar as componentes conexas atuais. - Detectar ciclos ao tentar unir dois v\u00e9rtices.</p>"},{"location":"Prova_3/Arvore_geradora_4/#principais-funcoes","title":"Principais fun\u00e7\u00f5es:","text":"<ul> <li><code>UFfind(v)</code>: encontra o representante da componente de <code>v</code>.</li> <li><code>UFunion(v, w)</code>: une as componentes dos v\u00e9rtices <code>v</code> e <code>w</code>.</li> </ul>"},{"location":"Prova_3/Arvore_geradora_4/#4-etapas-do-algoritmo","title":"\ud83e\ude9c 4. Etapas do Algoritmo","text":"<ol> <li>Inicializar <code>UFinit(n)</code> com <code>n</code> v\u00e9rtices.</li> <li>Ordenar todas as arestas por peso crescente.</li> <li>Iterar sobre cada aresta <code>(v, w)</code>:</li> <li> <p>Se <code>UFfind(v) != UFfind(w)</code>:</p> <ul> <li>Adiciona a aresta \u00e0 MST.</li> <li>Faz <code>UFunion(v, w)</code>.</li> </ul> </li> <li> <p>Parar quando a MST tiver <code>n - 1</code> arestas.</p> </li> </ol>"},{"location":"Prova_3/Arvore_geradora_4/#5-codigo-em-c-union-find","title":"5. C\u00f3digo em C \u2014 Union-Find","text":"<pre><code>int\nUFfind(int v) {\n   while (v != id[v]) v = id[v];\n   return v;\n}\n\nvoid\nUFunion(int v, int w) {\n   int i = UFfind(v), j = UFfind(w);\n   if (i == j) return;\n   if (sz[i] &lt; sz[j]) {\n      id[i] = j; sz[j] += sz[i];\n   } else {\n      id[j] = i; sz[i] += sz[j];\n   }\n}\n</code></pre>"},{"location":"Prova_3/Arvore_geradora_4/#6-complexidade","title":"6. Complexidade","text":"<ul> <li>Ordenar arestas: O(Elog\u2061E)O(ElogE)</li> <li>Opera\u00e7\u00f5es UF: quase constantes com heur\u00edsticas (custo quase linear).</li> <li>Complexidade total: O(Elog\u2061E)O(ElogE), onde EE \u00e9 o n\u00famero de arestas.</li> </ul>"},{"location":"Prova_3/Arvore_geradora_4/#7-observacoes","title":"7. Observa\u00e7\u00f5es","text":"<ul> <li>Kruskal \u00e9 especialmente eficiente para grafos esparsos.</li> <li>O algoritmo constr\u00f3i uma MST de forma incremental e global (escolhe arestas em ordem global, diferente do Prim que cresce localmente).</li> </ul>"},{"location":"Prova_3/Arvore_geradora_5/","title":"Estrutura Union-Find (Disjoint Set Union - DSU)","text":""},{"location":"Prova_3/Arvore_geradora_5/#1-objetivo","title":"1. Objetivo","text":"<p>A estrutura union-find serve para representar conjuntos disjuntos de forma eficiente, com suporte para as opera\u00e7\u00f5es:</p> <ul> <li><code>find(v)</code>: identificar a qual conjunto pertence o elemento <code>v</code>.</li> <li><code>union(v, w)</code>: unir os conjuntos contendo os elementos <code>v</code> e <code>w</code>.</li> </ul>"},{"location":"Prova_3/Arvore_geradora_5/#2-representacao-interna","title":"2. Representa\u00e7\u00e3o Interna","text":""},{"location":"Prova_3/Arvore_geradora_5/#vetores-usados","title":"Vetores usados:","text":"<ul> <li><code>id[]</code>: vetor de inteiros, onde <code>id[v]</code> aponta para o \"pai\" de <code>v</code>. Se <code>v</code> \u00e9 o representante (raiz) de seu conjunto, ent\u00e3o <code>id[v] == v</code>.</li> <li><code>sz[]</code>: tamanho da \u00e1rvore representando cada conjunto (usado para balancear).</li> </ul>"},{"location":"Prova_3/Arvore_geradora_5/#3-operacoes-basicas","title":"3. Opera\u00e7\u00f5es B\u00e1sicas","text":""},{"location":"Prova_3/Arvore_geradora_5/#inicializacao-ufinitn","title":"Inicializa\u00e7\u00e3o: <code>UFinit(n)</code>","text":"<pre><code>void UFinit(int n) {\n   for (int i = 0; i &lt; n; i++) {\n      id[i] = i;\n      sz[i] = 1;\n   }\n}\n</code></pre>"},{"location":"Prova_3/Arvore_geradora_5/#busca-uffindv","title":"Busca: <code>UFfind(v)</code>","text":"<pre><code>int UFfind(int v) {\n   while (v != id[v])\n      v = id[v];\n   return v;\n}\n</code></pre>"},{"location":"Prova_3/Arvore_geradora_5/#uniao-ufunionvw","title":"Uni\u00e3o: <code>UFunion(v,w)</code>","text":"<pre><code>void UFunion(int v, int w) {\n   int i = UFfind(v);\n   int j = UFfind(w);\n   if (i == j) return;\n\n   if (sz[i] &lt; sz[j]) {\n      id[i] = j;\n      sz[j] += sz[i];\n   } else {\n      id[j] = i;\n      sz[i] += sz[j];\n   }\n}\n</code></pre> <ul> <li>Une as \u00e1rvores representando os conjuntos.</li> <li>Sempre liga a menor \u00e1rvore na maior, evitando crescimento desbalanceado.</li> </ul>"},{"location":"Prova_3/Arvore_geradora_5/#4-heuristicas-de-otimizacao","title":"4. Heur\u00edsticas de Otimiza\u00e7\u00e3o","text":"<ul> <li>Balanceamento por Tamanho (sz[])<ul> <li>Garante que a altura da \u00e1rvore seja pequena.</li> <li>Evita piores casos como listas encadeadas.</li> </ul> </li> <li>Compress\u00e3o de Caminho (n\u00e3o inclu\u00edda no c\u00f3digo base)<ul> <li>Ao fazer find, torna todos os v\u00e9rtices no caminho filhos diretos da raiz.</li> <li>Reduz a profundidade e melhora a efici\u00eancia futura.</li> </ul> </li> </ul>"},{"location":"Prova_3/Arvore_geradora_5/#5-complexidade","title":"5. Complexidade","text":"<ul> <li>Com heur\u00edsticas (balanceamento e compress\u00e3o de caminho), as opera\u00e7\u00f5es t\u00eam complexidade praticamente constante:</li> <li>O(\u03b1(n))(func\u00b8a\u02dco inversa de Ackermann)</li> <li>O(\u03b1(n))(func\u00b8\u200ba\u02dco inversa de Ackermann)</li> <li>Na pr\u00e1tica, \u03b1(n) &lt; 5 mesmo para valores muito grandes de n.</li> </ul>"},{"location":"Prova_3/Arvore_geradora_5/#6-aplicacoes-classicas","title":"6. Aplica\u00e7\u00f5es Cl\u00e1ssicas","text":"<ul> <li>Algoritmo de Kruskal para encontrar a MST.</li> <li>Detectar ciclos em grafos.</li> <li>Gerenciamento de componentes conexas din\u00e2micas.</li> <li>Clustering, sistemas de tipos, agrupamentos de estados.</li> </ul>"},{"location":"Prova_3/Grafos_6/","title":"Grafos","text":""},{"location":"Prova_3/Grafos_6/#peso-nas-arestas","title":"Peso nas arestas","text":"<p>imagine um grafo onde um v\u00e9rtice \u00e9 o Plano Piloto e ele est\u00e1 conectado a outro v\u00e9rtice que vamos chamar de Taguatinga, e imagine que a aresta \u00e9 EPIA e possui 40 km, ou seja, estamos dadno um peso para a aresta que comp\u00f5e esse grafo. Agora imagine outro v\u00e9rtice que \u00e9 o N\u00facleo Bandeirante, do Plano Piloto para o N\u00facleo Bandeirante temos uma aresta de 30 km e de Taguuatinga para o N\u00facleo Bandeirante temos uma aresta de 20 km. Olhando o grafo abaixo percebemos de forma intuitiva o seguinte: Se eu quiser ir do Plano Piloto para o N\u00facleo Bandeirante eu n\u00e3o vou querer ir para Taguatinga antes, vamos ver que gastar\u00edamos 60 km ao inv\u00e9s dos 30 km na conex\u00e3o direta.</p> <p>Grafo 9: Exemplo Grafo Bras\u00edlia</p> <p>Fonte - Autoral</p> <ul> <li>Como implementar peso nas arestas?<ul> <li>Matriz de adjac\u00eancias: Antes nos grafos, das matrizes de ajjac\u00eancias, marc\u00e1vamos com valor bin\u00e1rio a conex\u00e3o dos v\u00e9rtices, ou seja, ao inv\u00e9s de colocar um, dentro da matriz de adjac\u00eancia j\u00e1 colocamos o peso na matriz.</li> <li>Lista de adjac\u00eancia: Na nossa struct node {int v; link next;}; Respons\u00e1vel pelas arestas, agora n\u00f3s adicionamos um inteiro para ser o peso das nossas arestas, ficaria algo como:</li> </ul> </li> </ul> <p>Nova struct das arestas para peso nas arestas</p> <pre><code>struct Edge {int v, int c, link next};\n// int c \u00e9 o peso da aresta\n</code></pre> <ul> <li>Como eu saio de um v\u00e9rtice qualquer e chego em outro com o menor custo? Temos algoritmos para ele como:<ul> <li>Bellmon Ford:<ul> <li>Calcula o caminho mais curto de um \u00fanico v\u00e9rtice</li> </ul> </li> <li>Dijkstra:<ul> <li>Calcula o caminho mais curto de um \u00fanico v\u00e9rtice</li> </ul> </li> <li>A*:<ul> <li>Ao inv\u00e9s de calcular a origem para todos os destinos ele olha somente o ponto inicial e o final</li> </ul> </li> </ul> </li> <li>\"Calcule as dist\u00e2ncias para todos os v\u00e9rtices que voc\u00ea alcan\u00e7a\"</li> </ul> <p>Vamos implementar nessa aula o Bellmon Ford:</p>"},{"location":"Prova_3/Grafos_6/#bellmon-ford","title":"Bellmon Ford","text":"<pre><code>bool GRAPHcptBF(Graph G, int s, int *pa, int *dist){ // int s = V\u00e9rtice de origem, int *dist = fala a dist\u00e2ncia para os v\u00e9rtices que conseguimos alcan\u00e7ar\n    bool onqueue[1000]; // N\u00e3o queremos inserir o mesmo v\u00e9rtice mais d euma vez na fila\n    for(int v = 0; v &lt; G-&gt;v; v++)\n        pa[v] = -1, dist[v] = INT_MAX, onqueue[v] = false;  // aqui igual o pre da dfs onde vemos se j\u00e1 foi visitado temos o pa, e como n\u00e3o sabemos a dist\u00e2ncia inicializamos com infinito. Inicializamos todos com -1 pois n\u00e3o visitamos nenhum.\n    pa[s] = s;     \n    dist[s] = 0;\n    Queueint(G-&gt;E);\n    onqueue[s] = true;\n    Queueput(V); // V\u00e9rtice sentinela\n    int k = 0;\n    while(1){\n        int v = Queueget()\n        if(v &lt; V){\n            for(link a = G-&gt;adj[v]; a != NULL; a = a-&gt;next){\n                if(dist[v] + a-&gt;c &lt; dist[a-&gt;v]){ // Ele v\u00ea o menor custo e ent\u00e3o\n                    dist[a-&gt;v] = dist[v] + a-&gt;c;\n                    pa[a-&gt;v] = v;\n                    if(onqueue[e-&gt;v]== false){\n                        Queueput(a-&gt;v);\n                        onqueue[e-&gt;v] = true;\n                    }\n                }\n            }\n        }else{\n            if(Queueempty()) \n                return true;\n            if(++k &gt;= G-&gt;V)\n                return false;\n            Queueput(V)\n            for (int t = 0; t &lt; G-&gt;v; t++)\n                onqueue[t] = false;\n        }\n    }\n}\n</code></pre>"},{"location":"Prova_3/Grafos_6/#execucao-manual","title":"Execu\u00e7\u00e3o manual","text":""},{"location":"Prova_3/Grafos_6/#resumo-chatgpt","title":"Resumo ChatGPT","text":"<p>1 - Grafos com Pesos - Em um grafo com pesos, cada aresta pode representar um custo, dist\u00e2ncia, tempo, etc. - Exemplo usado: mapa de regi\u00f5es do DF com dist\u00e2ncias entre cidades (Plano Piloto, Taguatinga, N\u00facleo Bandeirante). - A escolha do caminho ideal depende do peso total acumulado.</p> <p>2 - Representa\u00e7\u00f5es com Pesos</p> <ul> <li>Matriz de Adjac\u00eancia:<ul> <li>Cada c\u00e9lula armazena o peso da aresta entre dois v\u00e9rtices.</li> <li>Se n\u00e3o h\u00e1 aresta, valor padr\u00e3o pode ser zero ou infinito.</li> </ul> </li> <li>Lista de Adjac\u00eancia:<ul> <li>Cada n\u00f3 da lista cont\u00e9m o v\u00e9rtice de destino e o peso da aresta.</li> <li>A estrutura pode ser expandida com mais dados, como nome da cidade, estoque, etc.</li> </ul> </li> </ul> <p>3 - Aplica\u00e7\u00f5es Pr\u00e1ticas</p> <ul> <li>Exemplo de log\u00edstica: uma empresa precisa entregar uma televis\u00e3o de um galp\u00e3o ao cliente.<ul> <li>Os v\u00e9rtices podem representar galp\u00f5es log\u00edsticos, estoque dispon\u00edvel, e clientes.</li> <li>As arestas representam rotas entre os galp\u00f5es com seus respectivos custos.</li> </ul> </li> </ul> <p>4 - Problema de Caminho M\u00ednimo (Cheapest Path)</p> <ul> <li>Deseja-se encontrar o menor custo para ir de um v\u00e9rtice de origem at\u00e9 um destino.</li> <li>Tr\u00eas algoritmos foram destacados:</li> <li>Bellman-Ford<ul> <li>Funciona com pesos negativos.</li> <li>Detecta ciclos negativos (quando \u00e9 poss\u00edvel reduzir indefinidamente o custo).</li> <li>Serve para encontrar o menor caminho a partir de um \u00fanico v\u00e9rtice para todos os outros.</li> </ul> </li> <li>Dijkstra<ul> <li>Funciona somente com pesos positivos ou nulos.</li> <li>Mais eficiente que Bellman-Ford em muitos casos.</li> <li>Tamb\u00e9m calcula o caminho mais curto a partir de um \u00fanico v\u00e9rtice.</li> </ul> </li> <li>A* (A estrela)<ul> <li>Usado em jogos e intelig\u00eancia artificial </li> <li>Calcula caminho entre dois v\u00e9rtices espec\u00edficos.</li> <li>Usa uma fun\u00e7\u00e3o heur\u00edstica para evitar explorar caminhos desnecess\u00e1rios.</li> </ul> </li> </ul> <p>5 - Ciclos Negativos</p> <ul> <li>Quando existe um caminho fechado com soma total de pesos negativa.</li> <li>Bellman-Ford \u00e9 capaz de detectar esses ciclos e abortar o c\u00e1lculo.</li> <li>Nenhum algoritmo comum \u00e9 capaz de encontrar o menor caminho corretamente em presen\u00e7a de ciclos negativos.</li> </ul> <p>6 - Complexidade e Desempenho</p> <ul> <li>Bellman-Ford tem complexidade maior, mas \u00e9 mais robusto.</li> <li>Dijkstra \u00e9 mais r\u00e1pido, mas menos flex\u00edvel (n\u00e3o funciona com pesos negativos).</li> <li>A escolha do algoritmo depende do problema e das caracter\u00edsticas do grafo.</li> </ul> <p>7 - Import\u00e2ncia na Modelagem</p> <ul> <li>Grafos com pesos s\u00e3o essenciais para:<ul> <li>Problemas de log\u00edstica, rede de transportes, comunica\u00e7\u00f5es.</li> <li>Otimiza\u00e7\u00e3o de rotas, planejamento de entrega, e an\u00e1lise de conectividade.</li> </ul> </li> </ul>"},{"location":"Prova_3/Grafos_7/","title":"Grafos","text":"<p>Nessa aula vamos implementar o algorutmo Dijkstra, ent\u00e3o vamos l\u00e1:</p>"},{"location":"Prova_3/Grafos_7/#dijkstra-ingenuo","title":"Dijkstra (ing\u00eanuo)","text":"<ul> <li>Outro algoritmo para encontrar caminhos m\u00ednimos, no caso o Dijkstra, geralmente tem um desempenho melhor.</li> <li>O grafo s\u00f3 pode ter arestas com pesos positivos. </li> <li>Fun\u00e7\u00e3o com bom desempenho para grafos n\u00e3o t\u00e3o ing\u00eanuos, para grafos muito ing\u00eanuos sua complexidade ainda fica pr\u00f3xima a v\u00b2.</li> <li>A ideia do algoritmo \u00e9 sair de um v\u00e9rtice e ele n\u00e3o sabe qual o seu destino, mas ele te fornece todos os menores caminhos para os outros v\u00e9rtices e voc\u00ea analisa o que voc\u00ea quer. Ao final temos uma \u00e1rvore geradora criada a partir da raiz.</li> </ul> <pre><code>void GRAPHcptD1(Graph G, int s, int *pa, int *dist){\n    bool mature[1000];  // Um v\u00e9rtice maduro \u00e9 quando eu j\u00e1 explorei todo mundo que esse v\u00e9rtice sai\n    for(int v = 0; v &lt; G-&gt; v; v++)\n        pa[v] = -1;, mature[v] = false, dist[v] = INT_MAX;\n    pa[s] = 1;\n    dist[s] = 0;\n    while(true){\n        int min = INT_MAX;\n        int y;\n        for(int z = 0; z &lt; G-&gt;v; z++){\n            if(mature[z]) continue;\n            if(dist[z] &lt; min){\n                min = dist[z];\n                y = z;\n            }\n        }\n        if(min == INT_MAX)\n            break;\n        for(link a = G&gt;adj[y]; a != NULL; a = a-&gt;next){ // Para listas de adjac\u00eancias\n            if(mature[a-&gt;v]) \n                continue;\n            if(dist[y] + a-&gt;c &lt; dist[a-&gt;v]){\n                dist[a-&gt;v] = dist[y] + a-&gt;c;\n                pa[a-&gt;v] = y;\n            }\n        } \n        mature[y] = true;\n    }\n}\n</code></pre>"},{"location":"Prova_3/Grafos_7/#execucao-manual","title":"Execu\u00e7\u00e3o manual","text":""},{"location":"Prova_3/Grafos_7/#resumo-chatgpt","title":"Resumo ChatGPT","text":"Algoritmo Aceita Pesos Negativos Detecta Ciclos Negativos Complexidade Bellman-Ford \u2705 Sim \u2705 Sim O(V \u00d7 E) Dijkstra \u274c N\u00e3o \u274c N\u00e3o O((V + E) log V) <ul> <li>Para grafos somente com pesos positivos Drijkstra \u00e9 melhor.</li> </ul>"},{"location":"Prova_3/resumo/","title":"\ud83d\udcd8 Tabela T\u00e9cnica Resumo \u2014 Dijkstra, Bellman-Ford, Prim e Kruskal","text":"Crit\u00e9rio / Algoritmo Dijkstra Bellman-Ford Prim Kruskal Objetivo Menor caminho a partir de um v\u00e9rtice Menor caminho com suporte a pesos negativos Encontrar \u00c1rvore Geradora M\u00ednima (MST) Encontrar \u00c1rvore Geradora M\u00ednima (MST) Tipo de Grafo Direcionado ou n\u00e3o, pesos \u2265 0 Direcionado ou n\u00e3o, suporta pesos &lt; 0 N\u00e3o direcionado, pesos \u2265 0 N\u00e3o direcionado, pesos \u2265 0 Permite pesos negativos? \u274c N\u00e3o \u2705 Sim \u2705 Sim \u2705 Sim Detec\u00e7\u00e3o de ciclos negativos \u274c N\u00e3o \u2705 Sim \u274c N\u00e3o \u274c N\u00e3o Estrat\u00e9gia Guloso (expande menor custo) Relaxamento iterativo Guloso (expande a \u00e1rvore) Guloso (ordena arestas e une conjuntos) In\u00edcio Um v\u00e9rtice origem Um v\u00e9rtice origem Um v\u00e9rtice qualquer Come\u00e7a com todas as arestas Expans\u00e3o V\u00e9rtice a v\u00e9rtice Relaxa todas as arestas Cresce \u00e1rvore a partir de v\u00e9rtice inicial Junta componentes com menor aresta Estrutura principal Fila de prioridade (heap), vetores dist[], pred[] Fila otimizada (SPFA), vetores dist[], pa[], onqueue[] Fila de prioridade, preco[], pais[] Union-Find (Disjoint Set) Forma de entrada ideal Lista de adjac\u00eancia Lista de adjac\u00eancia Lista de adjac\u00eancia Lista de arestas Verifica\u00e7\u00e3o de ciclos Impl\u00edcita (via visitado[]) Detecta ciclos negativos com controle de itera\u00e7\u00e3o Impl\u00edcita (evita adicionar v\u00e9rtices repetidos) Expl\u00edcita (via Union-Find) Complexidade de tempo (sem otimiza\u00e7\u00e3o) O(V\u00b2) com matriz O(V\u00b7E) O(V\u00b2) com matriz O(E log E) Complexidade com otimiza\u00e7\u00e3o O((V + E) log V) com heap SPFA otimiza para casos m\u00e9dios, mas pior caso O(V\u00b7E) O((V + E) log V) com heap O(E log V) com Union-Find eficiente Espa\u00e7o (mem\u00f3ria) O(V + E) O(V + E) O(V + E) O(V + E) Funcionamento em grafos desconexos \u274c N\u00e3o encontra caminhos \u2705 Sim (trata desconexos com dist=\u221e) \u274c S\u00f3 funciona corretamente em grafos conexos \u2705 Sim (gera floresta m\u00ednima) Caminho ou \u00e1rvore? Caminhos m\u00ednimos Caminhos m\u00ednimos \u00c1rvore Geradora M\u00ednima (MST) \u00c1rvore Geradora M\u00ednima (MST) Usos comuns GPS, mapas, redes de transporte Moedas, arbitragem, redes com penalidades Redes de computadores, cabeamento Engenharia el\u00e9trica, clusteriza\u00e7\u00e3o, redes Resultado final Vetor de dist\u00e2ncias m\u00ednimas (dist[]) e predecessores (pred[]) Vetor de dist\u00e2ncias e pais (pa[]) Vetor pais[] com MST Conjunto de arestas mst[] com MST Implementa\u00e7\u00e3o M\u00e9dia (requer heap) F\u00e1cil (vers\u00e3o b\u00e1sica), SPFA \u00e9 moderada M\u00e9dia (requer fila + atualiza\u00e7\u00e3o de custo) Simples (se j\u00e1 tem arestas e Union-Find)"},{"location":"Prova_3/resumo/#quando-usar-cada-algoritmo","title":"\ud83e\udded Quando usar cada algoritmo?","text":""},{"location":"Prova_3/resumo/#dijkstra","title":"\u2705 Dijkstra","text":"<ul> <li>Grafo sem pesos negativos</li> <li>Quer menor caminho de 1 v\u00e9rtice para os outros</li> <li>Alta performance desejada com heap</li> <li>Aplica\u00e7\u00f5es: mapas, rotas, redes, jogos</li> </ul>"},{"location":"Prova_3/resumo/#bellman-ford","title":"\u2705 Bellman-Ford","text":"<ul> <li>Grafo com pesos negativos</li> <li>Pode haver ciclo negativo</li> <li>N\u00e3o precisa de heap</li> <li>Aplica\u00e7\u00f5es: finan\u00e7as, c\u00e2mbio, algoritmos de arbitragem</li> </ul>"},{"location":"Prova_3/resumo/#prim","title":"\u2705 Prim","text":"<ul> <li>Grafo conexo e n\u00e3o direcionado</li> <li>Precisa da MST</li> <li>Grafo \u00e9 denso</li> <li>Cresce a \u00e1rvore a partir de 1 ponto</li> <li>Aplica\u00e7\u00f5es: redes cabeadas, conectividade de sensores</li> </ul>"},{"location":"Prova_3/resumo/#kruskal","title":"\u2705 Kruskal","text":"<ul> <li>Grafo n\u00e3o direcionado e possivelmente desconexo</li> <li>Precisa da MST (ou floresta m\u00ednima)</li> <li>Grafo \u00e9 esparso</li> <li>J\u00e1 tem ou pode extrair todas as arestas</li> <li>Aplica\u00e7\u00f5es: clustering, eletrifica\u00e7\u00e3o, florestas m\u00ednimas</li> </ul>"},{"location":"Prova_3/resumo/#dica-de-ouro-para-escolher","title":"\ud83d\udccc Dica de ouro para escolher:","text":"Situa\u00e7\u00e3o Algoritmo Ideal Preciso do menor caminho e n\u00e3o h\u00e1 pesos negativos Dijkstra Preciso do menor caminho com pesos negativos Bellman-Ford Quero a MST e o grafo \u00e9 denso e conexo Prim Quero a MST e o grafo \u00e9 esparso ou desconexo Kruskal Quero detectar ciclos negativos Bellman-Ford"}]}