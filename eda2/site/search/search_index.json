{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sobre o curso","text":"<p>Curso de Estruturas de dados 2 da FCTE, ministrado pelo professor Bruno C\u00e9sar Ribas.</p>"},{"location":"#aluno","title":"Aluno","text":"<p>Aluno de engenharia de software da faculdade do Gama (FCTE), foi l\u00edder de telemetria na F\u00f3rmula Gama Racing onde foi respons\u00e1vel por integrar e operar o painel do carro, assegurando comunica\u00e7\u00e3o eficaz com sensores e sistemas internose, e foi aluno pesquisador, onde participou de projeto de pesquisa sobre simula\u00e7\u00e3o de ve\u00edculo h\u00edbrido flex, utilizando Unreal e Microautobox, integrando MATLAB e Simulink para comunica\u00e7\u00e3o eficaz dos sistemas.</p> <sub>Gabriel Basto</sub>"},{"location":"Prova_2/Grafos_1/","title":"Grafos","text":""},{"location":"Prova_2/Grafos_1/#tipo-abstratdos-de-dados-itens","title":"Tipo abstratdos de dados: Itens","text":"<p>Para esse primeiro momento dentro do estudo de grafos n\u00e3o nos interessa muito o que tem dentro desses itens e sim como eles se relacionam com outros itens, ent\u00e3o por exemplo em uma lista telef\u00f4nica, temos itens de uma lista telef\u00f4nica, dentro desses itens temos o nome da pessoa e o n\u00famero de telefone dessa pessoa, consideramos que o nome da pessoa \u00e9 a chave que usamos para fazer a busca dentro das rela\u00e7\u00f5es que estabelecemos, mas esses dados dentro de uma tabela hash n\u00e3o se relacionam diretamente, agora pensando em grafos pensamos realmente nas rela\u00e7\u00f5es que os itens tem entre eles, mas tudo bem, quais s\u00e3o essas rela\u00e7\u00f5es?</p> <p> Podemos pensar primeiramente em um mapa, imagine que tra\u00e7ou uma rota da sua faculdade at\u00e9 sua casa, ele vai te gerar uma rota, podemos imaginar que cada interce\u00e7\u00e3o de ruas \u00e9 um n\u00f3 do nosso grafo e a pr\u00f3pria rua \u00e9 o caminho entre esses n\u00f3s, e tem rela\u00e7\u00e3o com os outros n\u00f3es pelas ruas. O maps ent\u00e3o relcionando com os grafos, ele calcula os n\u00f3s e define o melhor caminho at\u00e9 chegar no n\u00f3 de desejo. Outro conjunto de rela\u00e7\u00f5es que podemos relacionar com grafos s\u00e3o as p\u00e1ginas webs, pensando em um site, que tem acesso a outro, cada um desses hiperlinks \u00e9 um n\u00f3 do grafo que nos leva a outro site. Outro exemplo muito legal s\u00e3o circuitos el\u00e9tricos, com os pontos de conex\u00e3o sendo n\u00f3s do nosso grafo, e os fios os caminhos que nos levam aos outros n\u00f3s. Outro caso legal seria o exemplo de rede de computadores, por exemplo, na RNP (Rede nacional de pesquisa), toda vez no esquema que vemos a sigla de um estado em um roteador temos um ponto de rede para se comunicar com outra faculdade de outro estado, cada um dessas siglas representa um n\u00f3 de rede nos estado, e a linha que os liga \u00e9 o caminho de n\u00f3 a n\u00f3, o interessante desse exemplo \u00e9 que por exemplo imagine que caia uma rota DF para SP, o grafo busca outro caminho sem ser o direto entre esses dois estados, fazendo assim, n\u00e3o dependente de uma \u00fanica rota.</p>"},{"location":"Prova_2/Grafos_1/#o-que-e-um-grafo","title":"O que \u00e9 um grafo?","text":"<p>Um conjunto de v\u00e9rtices, e um conjunto de arestas (conectam pares distindos de v\u00e9rtices), os v\u00e9rtices s\u00e3o numerados de 0 a v-1, representamso os grafos com bolinhas ligadas por linhas que conectam os mesmos (Como estamos em um teclado de computador, indicaremos sem as bolinhas). </p> <p>Grafo 1: Exemplo (4 v\u00e9rtices de 0 at\u00e9 3)</p> <p>Fonte - Autoral</p>"},{"location":"Prova_2/Grafos_1/#algumas-regras-e-conceitos-fundamentais","title":"Algumas regras e conceitos fundamentais:","text":"<ul> <li>N\u00e3o temos uma aresta que sai dela e vai para ela mesma; </li> <li>Dois v\u00e9rtices s\u00e3o adjacentes entre eles, se eles se conectam por meio de uma aresta em comum; </li> <li>Se uma aresta sai por exemplo do n\u00f3 0 para o n\u00f3 2, o caminho \u00e9 de duas vias, ou seja, do 2 eu consigo ir para o 0; </li> <li>Essa \"via de m\u00e3o dupla\" pode ser interrompida em grafos que chamamos de grafos dirigidos, com uma seta no final da aresta temos a indica\u00e7\u00e3o de um caminho s\u00f3 de ida entre um n\u00f3 e outro (veja o grafo 2 abaixo); </li> </ul> <p>Grafo 2: Grafo dirigido</p> <p>Fonte - Autoral</p> <ul> <li>Um grafo com V v\u00e9rtices tem no m\u00e1ximo [v.(v-1)]/2 arestas</li> <li>Grafo completo: Todos os v\u00e9rtices se conectam com todos os v\u00e9rtices:</li> </ul> <p>Grafo 3: Grafo completo</p> <p>Fonte - Autoral</p> <ul> <li>Caminho no grafo: \u00c9 uma sequ\u00eancia de v\u00e9rtices em que cada v\u00e9rtice sucessivo \u00e9 adjacente ao predecessor do caminho, <ul> <li>Caminho simples temos v\u00e9rtices e arestas distintas.</li> <li>Um ciclo: \u00c9 um caminho que \u00e9 simples exceto pelo primeiro e \u00faltimo v\u00e9rtice que s\u00e3o os mesmos, veja a imagem abaixo, mostrando isso.</li> </ul> </li> </ul> <p>Grafo 4: Grafo c\u00edclico</p> <p>Fonte - Autoral</p> <ul> <li> <p>Um grafo \u00e9 conexo se h\u00e1 um caminho de cada v\u00e9rtice para todo outro v\u00e9rtice no pr\u00f3prio grafo.</p> <ul> <li>Um grafo conexo exige um caminho para todos os outros v\u00e9rtices enquanto um grafo completo tem que ter uma aresta para todos os outros v\u00e9rtices.</li> <li>Um grafo que n\u00e3o \u00e9 conexo consiste em um conjunto de componentes conexas, que s\u00e3o subgrafos conexos m\u00e1ximos.</li> </ul> </li> <li> <p>Um grafo conexo ac\u00edclico \u00e9 tamb\u00e9m chamado de \u00e1rvore.</p> <ul> <li>Um conjunto de \u00e1rvores \u00e9 chamado de floresta.</li> </ul> </li> <li> <p>Como \u00e9 a nossa ADT dos grafos?</p> </li> </ul> <pre><code>typedef struct {int v; int w;}Edge; // struct respons\u00e1vel por arestas (v e w s\u00e3o os v\u00e9rtices que ela conecta).\nEdge EDGE(int, int); // Chamada de inicializa\u00e7\u00e3o da fun\u00e7\u00e3o EDGE.\ntypedef struct graph *Graph; // strfuct respons\u00e1vel pelos grafos (ainda n\u00e3o definida).\nGraph GRAPHinit(int); // Fun\u00e7\u00e3o de inicializa\u00e7\u00e3o de um grafo, o int \u00e9 a quantidade de v\u00e9rtices.\nvoid GRAPHInsertE(Graph, Edge); // Insere as arestas dentro do grafo.\nvoid GRAPHRemoveE(Graph, Edge); // Remove uma aresta dentro do grafo.\nint GRAPHEdges(Edge[], Graph G); // Contador de arestas.\nGraph GRAPHCopy(Graph); // Me devolve um grafo, duplicando um grafo.\nvoid GRAPHDestroy(Graph); // Dar um free corretamente do grafo livrando espa\u00e7o.\n</code></pre> <ul> <li>Como \u00e9 a cara da minha struct graph?<ul> <li>Uma matriz de adjac\u00eancia.<ul> <li>Uma matriz onde indicamos quem est\u00e1 conectado com quem.</li> </ul> </li> </ul> </li> </ul>"},{"location":"Prova_2/Grafos_1/#matriz-de-adjacencia","title":"Matriz de adjac\u00eancia","text":"<p>Struct graph e a fun\u00e7\u00e3o GRAPHInit (inicia o grafo com os v\u00e9rtices)</p> <pre><code>struct graph{int V, int E; int **adj;} // int V = num_vertices, int E = num_aretas, int **adj = matriz_de_adjagencia inicializada\nGraph GRAPHInit(int v){\n    Graph G = malloc(sizeof(*G));\n    G-&gt;V = v; // Recebe os v\u00e9rtices colocados\n    G-&gt;E = 0; //Ainda sem arestas\n    G-&gt;adj = MATRIZInit(V,V, 0); // Inicializa a matriz de adjac\u00eancia com 0's\n    return G;\n}\n\n</code></pre> <p></p> <p>Fun\u00e7\u00e3o MATRIZInit (inicializa a matriz de adjac\u00eancia)</p> <pre><code>int** MATRIZInit(int linhas, int colunas, int valorInicial) {\n    // Aloca mem\u00f3ria para a matriz\n    int** matriz = (int*)malloc(linhas * sizeof(int));\n    for (int i = 0; i &lt; linhas; i++) {\n        matriz[i] = (int*)malloc(colunas * sizeof(int));\n        // Inicializa a linha com o valor inicial especificado\n        for (int j = 0; j &lt; colunas; j++) {\n            matriz[i][j] = valorInicial;\n        }\n    }\n    return matriz;\n}\n</code></pre> <p>Fun\u00e7\u00e3o GRAPHInsertE (Insere uma aresta no grafo)</p> <pre><code>void GRPAHInsertE(Graph G, Edge e){ // Custo O(1)\n    int v = e.v, w = e.w; // e = struct e v e w os v\u00e9rtices que ela vai atingir\n    if(G-&gt;adj[v][w] == 0)\n        G-&gt;E++;\n    G-&gt;adj[v][w] = 1;\n    G-&gt;adj[w][v] = 1; // Se n\u00e3o for um grafo dirigido ambas atribui\u00e7\u00f5es s\u00e3o verdade\n}\n</code></pre> <p>Fun\u00e7\u00e3o GRAPHRemoveE (Remove uma aresta no grafo)</p> <pre><code>void GRAPHRemoveE(Graph G, Edge e){ // Custo O(1)\n    int v = e.v, w = e.w;\n    if(G-&gt;adj[v][w] == 1)\n        G-&gt;E--;\n    G-&gt;adj[v][w] = 0;\n    G-&gt;adj[w][v] = 0; \n}\n</code></pre> <p>Fun\u00e7\u00e3o GRAPHEdges (Contador de aresta no grafo)</p> <pre><code>int GRAPHEdges(Edge a[], Graph G){ \n    int v, w, E = 0;\n    for(v = 0; v &lt; G-&gt;v; v++)\n        for(w =v+1; w &lt; G-&gt;w; w++) // Por n\u00e3o ser um grafo dirigido n\u00e3o precisamos olhar os v\u00e9rtices menores do que estamos analizando\n            if(G-&gt;adj[v][w] = 1)\n                a[E++] = EDGE(v,w);\n    return E;\n}\n</code></pre> <ul> <li>Quando um v\u00e9rtice se liga a outro, colocamos na matriz de adjac\u00eancia o n\u00famero 1, caso contr\u00e1rio deixamos com 0.</li> <li>Se n\u00e3o for dirigido colocamos de 0 para 5 e de 5 para 0 por exemplo para indicar que podemos fazer o caminho inverso.</li> </ul> <p>Exemplo te matriz adjacente do grafo</p> 0 1 2 3 4 5 6 0 1 1 1 1 1 1 2 1 3 1 1 1 4 1 5 1 1 6 <ul> <li>Al\u00e9m das matrizes de adjac\u00eancias podemos armazenar tamb\u00e9m nas listas de adjac\u00eancias</li> </ul>"},{"location":"Prova_2/Grafos_2/","title":"Grafos","text":""},{"location":"Prova_2/Grafos_2/#lista-de-adjagencias","title":"Lista de adjag\u00eancias","text":"<p>Qualquer opera\u00e7\u00e3o para percorrer os v\u00e9rtices para proucurar as arestas vamos gastar um tempo proporcional a v^2, por isso vamos utilizar as listas adjacentes, por mais que podemos utilizar aquelas t\u00e9cnica de n\u00e3o preecisar olhar os vertices meenores da matriz, ainda temos um tempo n\u00e3o muito agrad\u00e1vel para esse tipo de problema, ainda mais com muitas arestas e v\u00e9rtices. Uma maneira diferente mas que tem sua funcionalidade, ao inv\u00e9s de termos uma matriz teremos como se fosse um grande vetor, e cada \"coisa\" dentro desse vetor seja uma lista encadeada, e quando tiver uam aresta teremos um n\u00f3 sa\u00edndo dessa posi\u00e7\u00e3o do vetor e mostrando ao qual ele est\u00e1 ligado, e se n\u00e3o estivermos falando de um grafo dirigido, o outro tamb\u00e9m ter\u00e1 seu n\u00f3 apontado para ele.</p> <p>Vamos fazer nossas opera\u00e7\u00f5es, s\u00e3o essencialmente as mesmas da matriz de adjac\u00eancia, somente tomando cuidado sabendo que estamos falando de uma fila e n\u00e3o de uma matriz, adicionaremos ent\u00e3o o n\u00f3.</p> <p>Estrutura do n\u00f3 em lista de adjac\u00eancias</p> <pre><code>typedef struct node *link\nstruct node {int v; link next;}; // Struct das arestas\nstruct graph{int V; int E; link *adj;};\nlink NEW(int v; link next){\n    link x = malloc(sizeof *x);  // Cria a aresta\n    if(x == NULL)\n        tela_azul(); // N\u00e3o encontrou , ou n\u00e3o foi criado nenhuma estrutura\n    x-&gt;v = v;   // Adiciona na struct o v\n    x-&gt;next = next; // Coloca o link para a pr\u00f3xima dentro da struct\n    return x;\n}\n\ngraph GRAPHInit(int V){  // Cria o grafo\n    int v;\n    Graph G = malloc(sizeof *G);    // Aloca a quantidade de espa\u00e7o para os v\u00e9rtices\n    G-&gt;v = V;   // Recebe os v\u00e9rtices colocados\n    G-&gt;E = 0;   // Zera as arestas\n    G-&gt;adj = malloc(V*sizeof(link)); // Cria nosso vetor de adjac\u00eancias\n    for(v = 0; v &lt; V; v++)\n        G-&gt;adj[v] = NULL; //  Criamos uma lista de adjac\u00eancias e indicamos que est\u00e3o apontando para NULL, j\u00e1 que n\u00e3o temos arestas no momento.\n    return G;\n}\n\nvoid GRAPHInsert(Graph G, Edge e){  // Insere uma aresta\n    int v = e.v, w = e.w;\n    G-&gt;adj[v] = NEW(w, G-&gt;adj[v]); // Inserimos no in\u00edcio da lista simplesmente por ser mais barato.\n    G-&gt;adj[v] = NEW(v, G-&gt;adj[w]);\n    G-&gt;E++;\n}\n\nint GRAPHEdges(Edge a[], Graph G){ // Salva as arestas em um vetor e retorna a quantidade\n    int v, E=0;                    // Com a chamda a[], se tem que ja foi alocado o vetor do tamanho correto previamente\n    for(v = 0; v &lt; G-&gt;v; v++)\n        for(t = G-&gt;adj[v]; t != NULL; t = t-&gt;next)\n            if(v &lt; t-&gt; v)\n                a[E++] = EDGE(v, t-&gt;v);\n    return E;\n}\n</code></pre>"},{"location":"Prova_2/Grafos_2/#que-metodo-devo-usar","title":"Que m\u00e9todo devo usar?","text":"<p>Compara\u00e7\u00e3o entre vetor de arestas, matriz de adjac\u00eancia e lista de adjac\u00eancia.</p> Vetor de arestas Matriz de adjac\u00eancias Lista de adjac\u00eancias Espa\u00e7o E (quantidade de arestas) V^2 (v\u00e9rtices ao quadrado) V+E Pre\u00e7o para inicializar 1 V^2 V Copiar E V^2 E Destruir 1 V (free em cada v\u00e9rtice) E (Para cada v\u00e9rtice percorre todas as arestas) Inserir arestas 1 1 (L\u00ea o v e o w, e coloca valor 1 na matriz) 1 (Alocar 2 n\u00f3s um para v e um para w, adicionando sempre no in\u00edcio da lista encadeada) Encontrar e remover uma aresta E 1 (Pergunta se v e w \u00e9 1, e se quiser \u00e9 s\u00f3 remover) V (O m\u00e1ximo de arestas que um v\u00e9rtice pode ter \u00e9 exatamente a quantidade de v\u00e9rtices total) V \u00e9 isolado? (Se n\u00e3o tiver nenhuma aresta conectada ao v\u00e9rtice) E (Anda em todas as arestas buscando uma rela\u00e7\u00e3o com outro V) V (percorre toda coluna do v\u00e9rtice para ver se todos os \u00edndices est\u00e3o marcados como 0) 1 (Basta perguntar no \u00edndice para o V se \u00e9 NULL) Caminho de U para V E.log(V) V^2 (Percorrer todas as arestas de U at\u00e9 chegar a v, logo se v\u00ea todas as conex\u00f5es da matriz) V+E"},{"location":"Prova_2/Grafos_2/#busca-em-profundidade-dfs","title":"Busca em profundidade (DFS)","text":"<p>Se eu quero passar por todos os v\u00e9rtices passando pleo menor caminho poss\u00edvel, como posso fazer isso? A busca em profundidade \u00e9 um \u00f3tima tentativa para achar labirintos. Imagine um corredor com 3 sa\u00eddas vamos tomar uma decis\u00e3o de onde ir, para isso vamos usar as pilhas.</p> <p>Busca em profundidade</p> <pre><code>int pre[V];\n\nvoid dfsR(Graph G, Edge e){\n    int t, w = e.w; \n    pre[w]=count++; // Mant\u00e9m a ordem de qual visitamos primeiro, e mostra quais v\u00e9rtices j\u00e1 foram visitados.\n    for(t = 0; t &lt; G-&gt;V, t++)\n        if(G-&gt;adj[w][t] != 0)\n            if(pre[t] == -1) // Para quando todos estiverem com valor diferente de -1, ou a fun\u00e7\u00e3o acaba e passamos por todos os v\u00e9rtices conexos por w\n                dfsR(G, EDGE(w, t));\n}\n\nint main(){\n    GRAPHInit(V);\n    for(int V = 0; V &lt; G-&gt;V; V++)\n        pre[v] = -1;\n    dfsR(G, EDGE(0, 0));\n}\n</code></pre> <p></p> <p>Se fizermos algo parecido com o c\u00f3digo de cima no grafo de baixo, come\u00e7ando do dfsR(G, EDGE(0,0)), ele percorrer\u00e1 todos de 0 at\u00e9 0 passando por todos os caminhos, mas perceba que nenhuma aresta passa pelo 0 e qualquer outro v\u00e9rtice e chega em 8 ou 9, logo ele n\u00e3o perocrrer\u00e1 em momento nenhum esses v\u00e9rtices.</p> <p>Se diferentemente executarmos a fun\u00e7\u00e3o dfsR(G, EDGE(8,8)), ele executar\u00e1 somente um caminho de 8-&gt;9, tendo em vista que s\u00f3 tem esse caminho, e n\u00f3s nesse modelo s\u00f3 contabilizamos a ida, j\u00e1 que a ida e a vinda \u00e9 a mesma aresta.</p> <p>Grafo 5: Grafo exemplo</p> <p>Fonte - Autoral</p>"},{"location":"Prova_2/Grafos_3/","title":"Grafos","text":""},{"location":"Prova_2/Grafos_3/#resumo-de-grafos","title":"Resumo de grafos","text":"<p>O importante \u00e9 definir a rela\u00e7\u00e3o entre os n\u00f3s, ent\u00e3o temos um conjunto de v\u00e9rtices que t\u00eam rela\u00e7\u00e3o com outro conjunto de v\u00e9rtices, tudo o que implementamos \u00e9 para fazer perguntas de como essas rela\u00e7\u00f5es se comportam ou se relacionam, essa conex\u00e3o se da por meio de arestas. Por mais que a estrutura gr\u00e1fica dos grafos seja simples com as bolinhas representando os v\u00e9rtices, e as linhas representando as arestas, quando tratamos essa estrutura na an\u00e1lise de dados essa estrutura j\u00e1 n\u00e3o \u00e9 mais t\u00e3o simples quanto aparenta ser.</p> <p>Podemos representar o grafo de duas formas:</p> <ul> <li>Matriz de adjac\u00eancia: N\u00famero 1 quando tem rela\u00e7\u00e3o e 0 quando n\u00e3o tem rela\u00e7\u00e3o;</li> <li>Lista de adjac\u00eancia: Colocamos no \u00edndice do vetor um link para os outros v\u00e9rtices com que eles est\u00e3o ligados pela arestas;</li> </ul>"},{"location":"Prova_2/Grafos_3/#componentes-conexas","title":"Componentes conexas","text":"<p>Como podemos identificar as componentes conexas usando busca em profundidade? Bem, para isso vamos pegar como exemplo o grafo abaixo j\u00e1 msotrado na aula passada, veja abaixo:</p> <p>Grafo 5: Grafo exemplo</p> <p>Fonte - Autoral</p> <p>Como podemos ver no grafo acima temos duas componentes conexas: Todo grupo unido com o 0 de um lado, e do outro o 9 junto do 8. Como podemos fazer isso? Bom mas antes de fazer isso vamos fazer uma fun\u00e7\u00e3o gen\u00e9rica para fazer uma busca geral no gr\u00e1fico, contando quantos v\u00e9rtices eu visitei</p> <p>Fun\u00e7\u00e3o GRAPHSearch para lista de adjac\u00eancias</p> <pre><code>static int count, pre[maxV];\nvoid GRAPHSearch(Graph G){  // Com esse algoritmo o sistema computa a sa\u00edda da componente conexa e vai para a pr\u00f3xima\n    int v; // V\u00e9rtices que vou visitar\n    int conexos = 0;\n    count = 0;\n    for(v = 0; G-&gt;V; v++)\n        pre[v]=-1;\n    for(v = 0; G-&gt;V; v++){ // Executa todos de 0 a 7, na segunda intera\u00e7\u00e3o ele faz a intera\u00e7\u00e3o de 8 e 9\n        if(pre[v] == -1){ // Se for != de -1 ele nem entra na DSF\n            dsfR(G, EDGE(v, v));\n            conexos++;\n        }\n    }\n}\n</code></pre> <p>dfsR para lista de ajac\u00eancia</p> <pre><code>void dfsR(Graph G, Edge e){\n    int t, w = e.w;\n    link l;\n    pre[w] = count++;\n    for(l=G-&gt;adj[w]; l != NULL; l = l-&gt;next){\n        t = l-&gt;v;\n        if(pre[t] == -1)    \n            dfsR(G, EDGE(w, t));\n    }\n}\n</code></pre> <p>Fun\u00e7\u00e3o GRAPHSearch para lista de adjac\u00eancias</p> <pre><code>static int count, pre[maxV];\nvoid GRAPHSearch(Graph G){  \n    int v; \n    int conexos = 0;\n    count = 0;\n    for(v = 0; G-&gt;V; v++)\n        pre[v]=-1;\n    for(v = 0; G-&gt;V; v++){ \n        if(pre[v] == -1){ \n            dsfRM(G, EDGE(v, v)); // \u00danica mudan\u00e7a para o GRAPHSearch antigo. \u00c9 chamar a dsfRM, ou seja a dsf da matriz de adjac\u00eancia\n            conexos++;\n        }\n    }\n}\n</code></pre> <p>dfsRM para matriz de ajac\u00eancia</p> <pre><code>void dfsRM(Graph G, Edge e) {\n    int w = e.w;\n    pre[w] = count++;\n    for (int t = 0; t &lt; G-&gt;V; t++) {\n        if (G-&gt;adj[w][t] == 1 &amp;&amp; pre[t] == -1) {\n            dfsR(G, EDGE(w, t));\n        }\n    }\n}\n</code></pre>"},{"location":"Prova_2/Grafos_3/#execucao-manual","title":"Execu\u00e7\u00e3o manual","text":""},{"location":"Prova_2/Grafos_4/","title":"Grafos","text":""},{"location":"Prova_2/Grafos_4/#busca-em-largura-bfs","title":"Busca em largura (BFS)","text":"<p>O BFS \u00e9 prefer\u00edvel quando se busca encontrar o caminho mais curto entre dois n\u00f3s em um grafo n\u00e3o ponderado (onde todas as arestas t\u00eam o mesmo peso), enquanto o DFS \u00e9 mais eficiente quando se busca explorar um grafo em profundidade, ou quando se deseja encontrar solu\u00e7\u00f5es que podem estar distantes da fonte.</p> <p>Algoritmo da BFS</p> <pre><code>void bfs(Graph G, Edge e){\n    int v, w;\n    Queueput(e);\n    pre[e.w] = count++;\n    while(!Queueempty()){\n        e = Queueget();\n        w = e.w;\n        for(l=G-&gt;adj[w]; l != NULL; l = l-&gt;next){\n            t = l-&gt;v;\n            if(pre[t] == -1){\n                Queueput(EDGE(w, t));\n                pre[t] = count++;\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"Prova_2/Grafos_4/#execucao-manual","title":"Execu\u00e7\u00e3o manual","text":""},{"location":"Prova_2/Grafos_5/","title":"Grafos","text":""},{"location":"Prova_2/Grafos_5/#grafos-dirigido","title":"Grafos dirigido","text":"<ul> <li>A ideia dos grafos dirigidos \u00e9 que agora as arestas dos grafos agora possuem dire\u00e7\u00f5es, diferente de alguns de nossos grafos mostrados anteriormente onde dentro das matriz de adjac\u00eancias ou da lista de adjac\u00eancias sempre que A apontava para B, ou vet[A][B] \u00e9 verdade, o nosso B apontava para A e vet[B][A] tamb\u00e9m era verdade. No caso do grafo dirigido temos uma via de m\u00e3o \u00fanica onde se A aponta para B, B n\u00e3o aponta para A por regra.</li> </ul> <p>Grafo 5: Grafo dirigido exemplo</p> <p>Fonte - Autoral</p> <p></p> <p>Agora vamos observar abaixo a lista encadeada abaixo onde podemos ver como \u00e9 a forma\u00e7\u00e3o de uma lista encadeada para essa situa\u00e7\u00e3o de um d\u00edgrafo. N\u00e3o h\u00e1 uma grande diferen\u00e7a para com a lista encadeada para um grafo tradicional, sua \u00fanica difren\u00e7a \u00e9 que por regra se A aponta para B, B N\u00e3o aponta para A, mas como \u00e9 poss\u00edvel analisar a rela\u00e7\u00e3o dos v\u00e9rtices 2 e 3, eles apontam um para o outro, mas diferente de um grafo normal isso n\u00e3o \u00e9 uma regra.</p> <p></p> <p>Imagem 4: Lista encadeada de grafo dirigido (exemplo acima)</p> <p>Fonte - Autoral</p> <ul> <li> <p>O m\u00e1ximo de arestas em um grafo dirigido sem la\u00e7os \u00e9 v(v-1).</p> </li> <li> <p>Grafo dirigido (ou d\u00edgrafo): \u00c9 um conjunto de v\u00e9rtices e um conjunto de arestas dirigidas que conectam um par de v\u00e9rtices (Sem arestas duplicadas). Dizemos que essa aresta vai de um primeiro v\u00e9rtice para o seu segundo v\u00e9rtice.</p> </li> <li> <p>Edge{int v, int w}, v \u00e9 o primeiro e w \u00e9 o segundo, ou seja ele vai de v para w (novamente enfatizando que n\u00e3o obrigat\u00f3riamente esse w volta para v).</p> </li> <li> <p>Caminho dirigido: Em um grafo dirigido a lista de v\u00e9rtices no qual existe uma resta dirigida conectando cada v\u00e9rtice da lista a seu sucessor. Dizemos de um v\u00e9rtice t \u00e9 alcan\u00e7\u00e1vel de um v\u00e9rtice s se existe um caminho dirigido de s a t.</p> </li> <li> <p>Quantidade de arestas em um grafo n\u00e3o dirigido \u00e9 [v(v-1)]/2, j\u00e1 em um grafo dirigido temos v(v-1).</p> </li> </ul> <p>Como inverter as arestas de um grafo dirigido com listas encadeadas?&gt;</p> <pre><code>Graph GRAPHReverse(Graph G){\n    int v;\n    link t;\n    Graph R = GRAPHInit(G-&gt;v); // Iniciamos um segundo Grafo com a fun\u00e7\u00e3o de inicializar o grafo com a mesma quantidade de v\u00e9rtices\n    for (v=0; v &lt; G-&gt;V; v++) // Percorremos os v\u00e9rtices\n        for(t=G-&gt;adj[v]; t != NULL; t=t-&gt;next) // Para cada aresta t, conectada a partir de V\n            GRAPHinsert(R, EDGE(t-&gt;v, v)); // Agora inserimos cada aresta apoontada de forma invertida\n    return R;\n}\n</code></pre> <p>Como inverter as arestas de um grafo dirigido com matriz de adjac\u00eacias?&gt;</p> <pre><code>Graph GRAPHReverse(Graph G) {\n    int i, j;\n    Graph R = GRAPHInit(G-&gt;V); // Cria grafo com mesma quantidade de v\u00e9rtices\n    for (i = 0; i &lt; G-&gt;V; i++) {\n        for (j = 0; j &lt; G-&gt;V; j++) {\n            if (G-&gt;adj[i][j] == 1) { // Existe uma aresta de i para j\n                R-&gt;adj[j][i] = 1;   // No grafo reverso, vai de j para i\n            }\n        }\n    }\n    return R;\n}\n</code></pre>"},{"location":"Prova_2/Grafos_5/#dag","title":"DAG","text":"<ul> <li>Grafo dirigido ac\u00edclico (DAG - Directed aciclic graph): Grafo dirigido que n\u00e3o possiu ciclos (\u00c1rvores). <ul> <li>Quando eu digo que temos um DAG quero dizer que um v\u00e9rtice n\u00e3o volta para um v\u00e9rtice que est\u00e1 acima na ordem topol\u00f3gica. Veja o exemplo abaixo:</li> </ul> </li> </ul> <p>Grafo 6: Grafo dirigido ac\u00edclico</p> <p>Fonte - Autoral</p>"},{"location":"Prova_2/Grafos_5/#grafo-dirigido-fortemente-conexo","title":"Grafo dirigido fortemente conexo","text":"<ul> <li>Grafo dirigido fortemente conexo: Acontece se todos os v\u00e9rtices s\u00e3o alcan\u00e7\u00e1veis a partir de todos os v\u00e9rices. </li> </ul> <p>Grafo 7: Grafo dirigido fortemente conexo</p> <p>Fonte - Autoral</p>"},{"location":"Prova_2/Grafos_5/#alcancabilidade-e-fecho-transitivo","title":"Alcan\u00e7abilidade e fecho transitivo","text":"<ul> <li>Fecho transitivo de um grafo dirigido \u00e9 um grafo dirigido com um mesmo conjunto de v\u00e9rtices, mas com uma aresta de s a t no fecho transitico, se e somente se existe um caminho dirigido de s a t no grafo dirigido</li> </ul> <p>Grafo 8: Grafo dirigido exemplo p\u00e1ra fexho transitivo</p> <p>Fonte - Autoral</p> <p>O fecho transitivo desse grafo segue abaixo:</p> <p>Imagem 5: Exemplo de fecho transitivo</p> <p>Fonte - Autoral</p> <p>Resumindo ent\u00e3o o fecho transitivo seria um grafo que n\u00e3o conecta somente aos adjacentes apontados, mas tamb\u00e9m fa\u00e7a uma conex\u00e3o direta entre o ponto de onde ele sai e o v\u00e9rtice que ele aponta leva ele, ou seja se A-&gt;B e B-&gt;C, colocamos que o v\u00e9rtice A-&gt;B, A-&gt;C e B-&gt;C.</p>"},{"location":"Prova_2/Grafos_5/#algoritmo-floyd-warshal","title":"Algoritmo Floyd Warshal","text":"<ul> <li>Complexidade alta: Tende a n\u00b3, mas resolve todos os fechos transitivos de uma vez s\u00f3.</li> </ul> <p>Algoritmo Floyd Warshal para matriz de ajac\u00eancias GRAPHtc</p> <pre><code>void GRAPHtc(GRAPH G){\n    int i, s, t;\n    G-&gt;tc = MATRIZint(G-&gt;V, G-&gt;V, 0); // Teve que ser modificado na estrutura grafo, somente adicionar um ponteiro de ponteiro chamado tc\n    for(s = 0; s &lt; G-&gt;V; s++)\n        for(t = 0; t &lt; G-&gt;V; t++)\n            G-&gt;tc[s][t] = G-&gt;adj[s][t]; // Isso para cima \u00e9 para percorrer os v\u00e9rtices para copiar as conex\u00f5es que j\u00e1 temos no grafo\n    for(s = 0; s &lt; G-&gt;V; s++)\n        G-&gt;tc[s][s] = 1; // Indicando que ele alcan\u00e7a ele mesmo\n    for(i = 0;. i &lt; G-&gt;V; i++)\n        for(s = 0; s &lt; G-&gt;V; s++)\n            if(G-&gt;tc[s][i] == 1)\n                for(t = 0; t &lt; G-&gt;V; t++)\n                    if(G-&gt;tc[i][t] == 1)\n                        G-&gt;tc[s][t] = 1;\n}\n</code></pre> <p>A chamada dessa fun\u00e7\u00e3o, ent\u00e3o:</p> <pre><code>int GRAPHreach(Graph G, int s, int t){\n    return G-&gt;tc[s][t];\n}\n</code></pre> <p>Nesse caso \u00e9 melhor utilizar a matriz de adjac\u00eancias, j\u00e1 que esse grafo agora vai possuir muitas arestas, ou seja, a economia de mem\u00f3ria que a gente ia ter com a nossa lista de adjac\u00eancias, j\u00e1 n\u00e3o \u00e9 mais t\u00e3o vantajosa em rela\u00e7\u00e3o a matriz de adjac\u00eancias, e pior a nossa pergunta se nosso v\u00e9rtice s, tem conex\u00e3o com com t ia ter custo O(V), porque teria que percorrer todos os v\u00e9rtices, com quem o v\u00e9rtice s tem conex\u00e3o, mas o t pode n\u00e3o estar, ent\u00e3o precisamos de v-1, para encontrar, j\u00e1 com matriz de adjac\u00eancias a consulta para isso tem custo O(1).</p> <p></p> <p>O custo desse algoritmo \u00e9 n\u00b3, tornando ele bem caro para os algoritmos que vemos na mat\u00e9ria.</p>"},{"location":"Prova_2/Grafos_5/#resumo-dos-algoritmos","title":"Resumo dos algoritmos","text":"<p>A fun\u00e7\u00e3o GRAPHtc \u00e9 respons\u00e1vel por preparar a estrutura de dados (G-&gt;tc), e a fun\u00e7\u00e3o GRAPHreach \u00e9 usada para consultar rapidamente essa estrutura, respondendo se um v\u00e9rtice alcan\u00e7a outro no grafo. Essa separa\u00e7\u00e3o \u00e9 comum em algoritmos que fazem um pr\u00e9-processamento caro, mas permitem consultas r\u00e1pidas depois.</p>"},{"location":"Prova_2/Grafos_5/#execucao-manual","title":"Execu\u00e7\u00e3o manual","text":""},{"location":"Prova_3/Grafos_6/","title":"Grafos","text":""},{"location":"Prova_3/Grafos_6/#peso-nas-arestas","title":"Peso nas arestas","text":"<p>imagine um grafo onde um v\u00e9rtice \u00e9 o Plano Piloto e ele est\u00e1 conectado a outro v\u00e9rtice que vamos chamar de Taguatinga, e imagine que a aresta \u00e9 EPIA e possui 40 km, ou seja, estamos dadno um peso para a aresta que comp\u00f5e esse grafo. Agora imagine outro v\u00e9rtice que \u00e9 o N\u00facleo Bandeirante, do Plano Piloto para o N\u00facleo Bandeirante temos uma aresta de 30 km e de Taguuatinga para o N\u00facleo Bandeirante temos uma aresta de 20 km. Olhando o grafo abaixo percebemos de forma intuitiva o seguinte: Se eu quiser ir do Plano Piloto para o N\u00facleo Bandeirante eu n\u00e3o vou querer ir para Taguatinga antes, vamos ver que gastar\u00edamos 60 km ao inv\u00e9s dos 30 km na conex\u00e3o direta.</p> <p>Grafo 9: Exemplo Grafo Bras\u00edlia</p> <p>Fonte - Autoral</p> <ul> <li>Como implementar peso nas arestas?<ul> <li>Matriz de adjac\u00eancias: Antes nos grafos, das matrizes de ajjac\u00eancias, marc\u00e1vamos com valor bin\u00e1rio a conex\u00e3o dos v\u00e9rtices, ou seja, ao inv\u00e9s de colocar um, dentro da matriz de adjac\u00eancia j\u00e1 colocamos o peso na matriz.</li> <li>Lista de adjac\u00eancia: Na nossa struct node {int v; link next;}; Respons\u00e1vel pelas arestas, agora n\u00f3s adicionamos um inteiro para ser o peso das nossas arestas, ficaria algo como:</li> </ul> </li> </ul> <p>Nova struct das arestas para peso nas arestas</p> <pre><code>struct Edge {int v, int c, link next};\n// int c \u00e9 o peso da aresta\n</code></pre> <ul> <li>Como eu saio de um v\u00e9rtice qualquer e chego em outro com o menor custo? Temos algoritmos para ele como:<ul> <li>Bellmon Ford:<ul> <li>Calcula o caminho mais curto de um \u00fanico v\u00e9rtice</li> </ul> </li> <li>Dijkstra:<ul> <li>Calcula o caminho mais curto de um \u00fanico v\u00e9rtice</li> </ul> </li> <li>A*:<ul> <li>Ao inv\u00e9s de calcular a origem para todos os destinos ele olha somente o ponto inicial e o final</li> </ul> </li> </ul> </li> <li>\"Calcule as dist\u00e2ncias para todos os v\u00e9rtices que voc\u00ea alcan\u00e7a\"</li> </ul> <p>Vamos implementar nessa aula o Bellmon Ford:</p>"},{"location":"Prova_3/Grafos_6/#bellmon-ford","title":"Bellmon Ford","text":"<pre><code>bool GRAPHcptBF(Graph G, int s, int *pa, int *dist){ // int s = V\u00e9rtice de origem, int *dist = fala a dist\u00e2ncia para os v\u00e9rtices que conseguimos alcan\u00e7ar\n    bool onqueue[1000]; // N\u00e3o queremos inserir o mesmo v\u00e9rtice mais d euma vez na fila\n    for(int v = 0; v &lt; G-&gt;v; v++)\n        pa[v] = -1, dist[v] = INT_MAX, onqueue[v] = false;  // aqui igual o pre da dfs onde vemos se j\u00e1 foi visitado temos o pa, e como n\u00e3o sabemos a dist\u00e2ncia inicializamos com infinito. Inicializamos todos com -1 pois n\u00e3o visitamos nenhum.\n    pa[s] = s;     \n    dist[s] = 0;\n    Queueint(G-&gt;E);\n    onqueue[s] = true;\n    Queueput(V); // V\u00e9rtice sentinela\n    int k = 0;\n    while(1){\n        int v = Queueget()\n        if(v &lt; V){\n            for(link a = G-&gt;adj[v]; a != NULL; a = a-&gt;next){\n                if(dist[v] + a-&gt;c &lt; dist[a-&gt;v]){ // Ele v\u00ea o menor custo e ent\u00e3o\n                    dist[a-&gt;v] = dist[v] + a-&gt;c;\n                    pa[a-&gt;v] = v;\n                    if(onqueue[e-&gt;v]== false){\n                        Queueput(a-&gt;v);\n                        onqueue[e-&gt;v] = true;\n                    }\n                }\n            }\n        }else{\n            if(Queueempty()) \n                return true;\n            if(++k &gt;= G-&gt;V)\n                return false;\n            Queueput(V)\n            for (int t = 0; t &lt; G-&gt;v; t++)\n                onqueue[t] = false;\n        }\n    }\n}\n</code></pre>"},{"location":"Prova_3/Grafos_6/#execucao-manual","title":"Execu\u00e7\u00e3o manual","text":""},{"location":"Prova_3/Grafos_6/#resumo-chatgpt","title":"Resumo ChatGpt","text":"<p>1 - Grafos com Pesos - Em um grafo com pesos, cada aresta pode representar um custo, dist\u00e2ncia, tempo, etc. - Exemplo usado: mapa de regi\u00f5es do DF com dist\u00e2ncias entre cidades (Plano Piloto, Taguatinga, N\u00facleo Bandeirante). - A escolha do caminho ideal depende do peso total acumulado.</p> <p>2 - Representa\u00e7\u00f5es com Pesos</p> <ul> <li>Matriz de Adjac\u00eancia:<ul> <li>Cada c\u00e9lula armazena o peso da aresta entre dois v\u00e9rtices.</li> <li>Se n\u00e3o h\u00e1 aresta, valor padr\u00e3o pode ser zero ou infinito.</li> </ul> </li> <li>Lista de Adjac\u00eancia:<ul> <li>Cada n\u00f3 da lista cont\u00e9m o v\u00e9rtice de destino e o peso da aresta.</li> <li>A estrutura pode ser expandida com mais dados, como nome da cidade, estoque, etc.</li> </ul> </li> </ul> <p>3 - Aplica\u00e7\u00f5es Pr\u00e1ticas</p> <ul> <li>Exemplo de log\u00edstica: uma empresa precisa entregar uma televis\u00e3o de um galp\u00e3o ao cliente.<ul> <li>Os v\u00e9rtices podem representar galp\u00f5es log\u00edsticos, estoque dispon\u00edvel, e clientes.</li> <li>As arestas representam rotas entre os galp\u00f5es com seus respectivos custos.</li> </ul> </li> </ul> <p>4 - Problema de Caminho M\u00ednimo (Cheapest Path)</p> <ul> <li>Deseja-se encontrar o menor custo para ir de um v\u00e9rtice de origem at\u00e9 um destino.</li> <li>Tr\u00eas algoritmos foram destacados:</li> <li>Bellman-Ford<ul> <li>Funciona com pesos negativos.</li> <li>Detecta ciclos negativos (quando \u00e9 poss\u00edvel reduzir indefinidamente o custo).</li> <li>Serve para encontrar o menor caminho a partir de um \u00fanico v\u00e9rtice para todos os outros.</li> </ul> </li> <li>Dijkstra<ul> <li>Funciona somente com pesos positivos ou nulos.</li> <li>Mais eficiente que Bellman-Ford em muitos casos.</li> <li>Tamb\u00e9m calcula o caminho mais curto a partir de um \u00fanico v\u00e9rtice.</li> </ul> </li> <li>A* (A estrela)<ul> <li>Usado em jogos e intelig\u00eancia artificial </li> <li>Calcula caminho entre dois v\u00e9rtices espec\u00edficos.</li> <li>Usa uma fun\u00e7\u00e3o heur\u00edstica para evitar explorar caminhos desnecess\u00e1rios.</li> </ul> </li> </ul> <p>5 - Ciclos Negativos</p> <ul> <li>Quando existe um caminho fechado com soma total de pesos negativa.</li> <li>Bellman-Ford \u00e9 capaz de detectar esses ciclos e abortar o c\u00e1lculo.</li> <li>Nenhum algoritmo comum \u00e9 capaz de encontrar o menor caminho corretamente em presen\u00e7a de ciclos negativos.</li> </ul> <p>6 - Complexidade e Desempenho</p> <ul> <li>Bellman-Ford tem complexidade maior, mas \u00e9 mais robusto.</li> <li>Dijkstra \u00e9 mais r\u00e1pido, mas menos flex\u00edvel (n\u00e3o funciona com pesos negativos).</li> <li>A escolha do algoritmo depende do problema e das caracter\u00edsticas do grafo.</li> </ul> <p>7 - Import\u00e2ncia na Modelagem</p> <ul> <li>Grafos com pesos s\u00e3o essenciais para:<ul> <li>Problemas de log\u00edstica, rede de transportes, comunica\u00e7\u00f5es.</li> <li>Otimiza\u00e7\u00e3o de rotas, planejamento de entrega, e an\u00e1lise de conectividade.</li> </ul> </li> </ul>"},{"location":"Prova_3/Grafos_7/","title":"Grafos","text":"<p>Nessa aula vamos implementar o algorutmo Dijkstra, ent\u00e3o vamos l\u00e1:</p>"},{"location":"Prova_3/Grafos_7/#dijkstra-ingenuo","title":"Dijkstra (ing\u00eanuo)","text":"<ul> <li>Outro algoritmo para encontrar caminhos m\u00ednimos, no caso o Dijkstra, geralmente tem um desempenho melhor.</li> <li>O grafo s\u00f3 pode ter arestas com pesos positivos. </li> <li>Fun\u00e7\u00e3o com bom desempenho para grafos n\u00e3o t\u00e3o ing\u00eanuos, para grafos muito ing\u00eanuos sua complexidade ainda fica pr\u00f3xima a v\u00b2.</li> <li>A ideia do algoritmo \u00e9 sair de um v\u00e9rtice e ele n\u00e3o sabe qual o seu destino, mas ele te fornece todos os menores caminhos para os outros v\u00e9rtices e voc\u00ea analisa o que voc\u00ea quer. Ao final temos uma \u00e1rvore geradora criada a partir da raiz.</li> </ul> <pre><code>void GRAPHcptD1(Graph G, int s, int *pa, int *dist){\n    bool mature[1000];  // Um v\u00e9rtice maduro \u00e9 quando eu j\u00e1 explorei todo mundo que esse v\u00e9rtice sai\n    for(int v = 0; v &lt; G-&gt; v; v++)\n        pa[v] = -1;, mature[v] = false, dist[v] = INT_MAX;\n    pa[s] = 1;\n    dist[s] = 0;\n    while(true){\n        int min = INT_MAX;\n        int y;\n        for(int z = 0; z &lt; G-&gt;v; z++){\n            if(mature[z]) continue;\n            if(dist[z] &lt; min){\n                min = dist[z];\n                y = z;\n            }\n        }\n        if(min == INT_MAX)\n            break;\n        for(link a = G&gt;adj[y]; a != NULL; a = a-&gt;next){ // Para listas de adjac\u00eancias\n            if(mature[a-&gt;v]) \n                continue;\n            if(dist[y] + a-&gt;c &lt; dist[a-&gt;v]){\n                dist[a-&gt;v] = dist[y] + a-&gt;c;\n                pa[a-&gt;v] = y;\n            }\n        } \n        mature[y] = true;\n    }\n}\n</code></pre>"}]}