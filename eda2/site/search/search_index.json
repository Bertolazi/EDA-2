{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sobre o curso","text":"<p>Curso de Estruturas de dados 2 da FCTE, ministrado pelo professor Bruno C\u00e9sar Ribas.</p>"},{"location":"#aluno","title":"Aluno","text":"<p>Aluno de engenharia de software da faculdade do Gama (FCTE), foi l\u00edder de telemetria na F\u00f3rmula Gama Racing onde foi respons\u00e1vel por integrar e operar o painel do carro, assegurando comunica\u00e7\u00e3o eficaz com sensores e sistemas internose, e foi aluno pesquisador, onde participou de projeto de pesquisa sobre simula\u00e7\u00e3o de ve\u00edculo h\u00edbrido flex, utilizando Unreal e Microautobox, integrando MATLAB e Simulink para comunica\u00e7\u00e3o eficaz dos sistemas.</p> <sub>Gabriel Basto</sub>"},{"location":"Prova_2/Grafos_1/","title":"Grafos","text":""},{"location":"Prova_2/Grafos_1/#tipo-abstratdos-de-dados-itens","title":"Tipo abstratdos de dados: Itens","text":"<p>Para esse primeiro momento dentro do estudo de grafos n\u00e3o nos interessa muito o que tem dentro desses itens e sim como eles se relacionam com outros itens, ent\u00e3o por exemplo em uma lista telef\u00f4nica, temos itens de uma lista telef\u00f4nica, dentro desses itens temos o nome da pessoa e o n\u00famero de telefone dessa pessoa, consideramos que o nome da pessoa \u00e9 a chave que usamos para fazer a busca dentro das rela\u00e7\u00f5es que estabelecemos, mas esses dados dentro de uma tabela hash n\u00e3o se relacionam diretamente, agora pensando em grafos pensamos realmente nas rela\u00e7\u00f5es que os itens tem entre eles, mas tudo bem, quais s\u00e3o essas rela\u00e7\u00f5es?</p> <p> Podemos pensar primeiramente em um mapa, imagine que tra\u00e7ou uma rota da sua faculdade at\u00e9 sua casa, ele vai te gerar uma rota, podemos imaginar que cada interce\u00e7\u00e3o de ruas \u00e9 um n\u00f3 do nosso grafo e a pr\u00f3pria rua \u00e9 o caminho entre esses n\u00f3s, e tem rela\u00e7\u00e3o com os outros n\u00f3es pelas ruas. O maps ent\u00e3o relcionando com os grafos, ele calcula os n\u00f3s e define o melhor caminho at\u00e9 chegar no n\u00f3 de desejo. Outro conjunto de rela\u00e7\u00f5es que podemos relacionar com grafos s\u00e3o as p\u00e1ginas webs, pensando em um site, que tem acesso a outro, cada um desses hiperlinks \u00e9 um n\u00f3 do grafo que nos leva a outro site. Outro exemplo muito legal s\u00e3o circuitos el\u00e9tricos, com os pontos de conex\u00e3o sendo n\u00f3s do nosso grafo, e os fios os caminhos que nos levam aos outros n\u00f3s. Outro caso legal seria o exemplo de rede de computadores, por exemplo, na RNP (Rede nacional de pesquisa), toda vez no esquema que vemos a sigla de um estado em um roteador temos um ponto de rede para se comunicar com outra faculdade de outro estado, cada um dessas siglas representa um n\u00f3 de rede nos estado, e a linha que os liga \u00e9 o caminho de n\u00f3 a n\u00f3, o interessante desse exemplo \u00e9 que por exemplo imagine que caia uma rota DF para SP, o grafo busca outro caminho sem ser o direto entre esses dois estados, fazendo assim, n\u00e3o dependente de uma \u00fanica rota.</p>"},{"location":"Prova_2/Grafos_1/#o-que-e-um-grafo","title":"O que \u00e9 um grafo?","text":"<p>Um conjunto de v\u00e9rtices, e um conjunto de arestas (conectam pares distindos de v\u00e9rtices), os v\u00e9rtices s\u00e3o numerados de 0 a v-1, representamso os grafos com bolinhas ligadas por linhas que conectam os mesmos (Como estamos em um teclado de computador, indicaremos sem as bolinhas). </p> <p>Grafo 1: Exemplo (4 v\u00e9rtices de 0 at\u00e9 3)</p> <p>Fonte - Autoral</p>"},{"location":"Prova_2/Grafos_1/#algumas-regras-e-conceitos-fundamentais","title":"Algumas regras e conceitos fundamentais:","text":"<ul> <li>N\u00e3o temos uma aresta que sai dela e vai para ela mesma; </li> <li>Dois v\u00e9rtices s\u00e3o adjacentes entre eles, se eles se conectam por meio de uma aresta em comum; </li> <li>Se uma aresta sai por exemplo do n\u00f3 0 para o n\u00f3 2, o caminho \u00e9 de duas vias, ou seja, do 2 eu consigo ir para o 0; </li> <li>Essa \"via de m\u00e3o dupla\" pode ser interrompida em grafos que chamamos de grafos dirigidos, com uma seta no final da aresta temos a indica\u00e7\u00e3o de um caminho s\u00f3 de ida entre um n\u00f3 e outro (veja o grafo 2 abaixo); </li> </ul> <p>Grafo 2: Grafo dirigido</p> <p>Fonte - Autoral</p> <ul> <li>Um grafo com V v\u00e9rtices tem no m\u00e1ximo [v.(v-1)]/2 arestas</li> <li>Grafo completo: Todos os v\u00e9rtices se conectam com todos os v\u00e9rtices:</li> </ul> <p>Grafo 3: Grafo completo</p> <p>Fonte - Autoral</p> <ul> <li>Caminho no grafo: \u00c9 uma sequ\u00eancia de v\u00e9rtices em que cada v\u00e9rtice sucessivo \u00e9 adjacente ao predecessor do caminho, <ul> <li>Caminho simples temos v\u00e9rtices e arestas distintas.</li> <li>Um ciclo: \u00c9 um caminho que \u00e9 simples exceto pelo primeiro e \u00faltimo v\u00e9rtice que s\u00e3o os mesmos, veja a imagem abaixo, mostrando isso.</li> </ul> </li> </ul> <p>Grafo 4: Grafo c\u00edclico</p> <p>Fonte - Autoral</p> <ul> <li> <p>Um grafo \u00e9 conexo se h\u00e1 um caminho de cada v\u00e9rtice para todo outro v\u00e9rtice no pr\u00f3prio grafo.</p> <ul> <li>Um grafo conexo exige um caminho para todos os outros v\u00e9rtices enquanto um grafo completo tem que ter uma aresta para todos os outros v\u00e9rtices.</li> <li>Um grafo que n\u00e3o \u00e9 conexo consiste em um conjunto de componentes conexas, que s\u00e3o subgrafos conexos m\u00e1ximos.</li> </ul> </li> <li> <p>Um grafo conexo ac\u00edclico \u00e9 tamb\u00e9m chamado de \u00e1rvore.</p> <ul> <li>Um conjunto de \u00e1rvores \u00e9 chamado de floresta.</li> </ul> </li> <li> <p>Como \u00e9 a nossa ADT dos grafos?</p> </li> </ul> <pre><code>typedef struct {int v; int w;}Edge; // struct respons\u00e1vel por arestas (v e w s\u00e3o os v\u00e9rtices que ela conecta).\nEdge EDGE(int, int); // Chamada de inicializa\u00e7\u00e3o da fun\u00e7\u00e3o EDGE.\ntypedef struct graph *Graph; // strfuct respons\u00e1vel pelos grafos (ainda n\u00e3o definida).\nGraph GRAPHinit(int); // Fun\u00e7\u00e3o de inicializa\u00e7\u00e3o de um grafo, o int \u00e9 a quantidade de v\u00e9rtices.\nvoid GRAPHInsertE(Graph, Edge); // Insere as arestas dentro do grafo.\nvoid GRAPHRemoveE(Graph, Edge); // Remove uma aresta dentro do grafo.\nint GRAPHEdges(Edge[], Graph G); // Contador de arestas.\nGraph GRAPHCopy(Graph); // Me devolve um grafo, duplicando um grafo.\nvoid GRAPHDestroy(Graph); // Dar um free corretamente do grafo livrando espa\u00e7o.\n</code></pre> <ul> <li>Como \u00e9 a cara da minha struct graph?<ul> <li>Uma matriz de adjac\u00eancia.<ul> <li>Uma matriz onde indicamos quem est\u00e1 conectado com quem.</li> </ul> </li> </ul> </li> </ul>"},{"location":"Prova_2/Grafos_1/#matriz-de-adjacencia","title":"Matriz de adjac\u00eancia","text":"<p>Struct graph e a fun\u00e7\u00e3o GRAPHInit (inicia o grafo com os v\u00e9rtices)</p> <pre><code>struct graph{int V, int E; int **adj;} // int V = num_vertices, int E = num_aretas, int **adj = matriz_de_adjagencia inicializada\nGraph GRAPHInit(int v){\n    Graph G = malloc(sizeof(*G));\n    G-&gt;V; // Recebe os v\u00e9rtices colocados\n    G-&gt;E = 0; //Ainda sem arestas\n    G-&gt;adj = MATRIZInit(V,V, 0); // Inicializa a matriz de adjac\u00eancia com 0's\n    return G;\n}\n\n</code></pre> <p></p> <p>Fun\u00e7\u00e3o MATRIZInit (inicializa a matriz de adjac\u00eancia)</p> <pre><code>int** MATRIZInit(int V) {\n    // Aloca mem\u00f3ria para a matriz\n    int** matriz = (int**)malloc(V * sizeof(int*));\n    for (int i = 0; i &lt; V; i++) {\n        matriz[i] = (int*)malloc(V * sizeof(int));\n\n        // Inicializa a linha com zeros\n        for (int j = 0; j &lt; V; j++) {\n            matriz[i][j] = 0;\n        }\n    }\n    return matriz;\n}\n</code></pre> <p>Fun\u00e7\u00e3o GRAPHInsertE (Insere uma aresta no grafo)</p> <pre><code>void GRPAHInsertE(Graph G, Edge e){ // Custo O(1)\n    int v = e.v, w = e.w; // e = struct e v e w os v\u00e9rtices que ela vai atingir\n    if(G-&gt;adj[v][w] == 0)\n        G-&gt;E++;\n    G-&gt;adj[v][w] = 1;\n    G-&gt;adj[w][v] = 1; // Se n\u00e3o for um grafo dirigido ambas atribui\u00e7\u00f5es s\u00e3o verdade\n}\n</code></pre> <p>Fun\u00e7\u00e3o GRAPHRemoveE (Remove uma aresta no grafo)</p> <pre><code>void GRAPHRemoveE(Graph G, Edge e){ // Custo O(1)\n    int v = e.v, w = e.w;\n    if(G-&gt;adj[v][w] == 1)\n        G-&gt;E--;\n    G-&gt;adj[v][w] = 0;\n    G-&gt;adj[w][v] = 0; \n}\n</code></pre> <p>Fun\u00e7\u00e3o GRAPHEdges (Contador de aresta no grafo)</p> <pre><code>int GRAPHEdges(Edge a[], Graph G){ \n    int v, w, E = 0;\n    for(v = 0; v &lt; G-&gt;v; v++)\n        for(w =v+1; w &lt; G-&gt;w; w++) // Por n\u00e3o ser um grafo dirigido n\u00e3o precisamos olhar os v\u00e9rtices menores do que estamos analizando\n            if(G-&gt;adj[v][w] = 1)\n                a[E++] = EDGE(v,w);\n    return E;\n}\n</code></pre> <ul> <li>Quando um v\u00e9rtice se liga a outro, colocamos na matriz de adjac\u00eancia o n\u00famero 1, caso contr\u00e1rio deixamos com 0.</li> <li>Se n\u00e3o for dirigido colocamos de 0 para 5 e de 5 para 0 por exemplo para indicar que podemos fazer o caminho inverso.</li> </ul> <p>Exemplo te matriz adjacente do grafo</p> 0 1 2 3 4 5 6 0 1 1 1 1 1 1 2 1 3 1 1 1 4 1 5 1 1 6 <ul> <li>Al\u00e9m das matrizes de adjac\u00eancias podemos armazenar tamb\u00e9m nas listas de adjac\u00eancias</li> </ul>"}]}