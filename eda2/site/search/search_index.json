{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sobre o curso","text":"<p>Curso de Estruturas de dados 2 da FCTE, ministrado pelo professor Bruno C\u00e9sar Ribas.</p>"},{"location":"#aluno","title":"Aluno","text":"<p>Aluno de engenharia de software da faculdade do Gama (FCTE), foi l\u00edder de telemetria na F\u00f3rmula Gama Racing onde foi respons\u00e1vel por integrar e operar o painel do carro, assegurando comunica\u00e7\u00e3o eficaz com sensores e sistemas internose, e foi aluno pesquisador, onde participou de projeto de pesquisa sobre simula\u00e7\u00e3o de ve\u00edculo h\u00edbrido flex, utilizando Unreal e Microautobox, integrando MATLAB e Simulink para comunica\u00e7\u00e3o eficaz dos sistemas.</p> <sub>Gabriel Basto</sub>"},{"location":"Prova_2/Grafos_1/","title":"Grafos","text":""},{"location":"Prova_2/Grafos_1/#tipo-abstratdos-de-dados-itens","title":"Tipo abstratdos de dados: Itens","text":"<p>Para esse primeiro momento dentro do estudo de grafos n\u00e3o nos interessa muito o que tem dentro desses itens e sim como eles se relacionam com outros itens, ent\u00e3o por exemplo em uma lista telef\u00f4nica, temos itens de uma lista telef\u00f4nica, dentro desses itens temos o nome da pessoa e o n\u00famero de telefone dessa pessoa, consideramos que o nome da pessoa \u00e9 a chave que usamos para fazer a busca dentro das rela\u00e7\u00f5es que estabelecemos, mas esses dados dentro de uma tabela hash n\u00e3o se relacionam diretamente, agora pensando em grafos pensamos realmente nas rela\u00e7\u00f5es que os itens tem entre eles, mas tudo bem, quais s\u00e3o essas rela\u00e7\u00f5es?</p> <p> Podemos pensar primeiramente em um mapa, imagine que tra\u00e7ou uma rota da sua faculdade at\u00e9 sua casa, ele vai te gerar uma rota, podemos imaginar que cada interce\u00e7\u00e3o de ruas \u00e9 um n\u00f3 do nosso grafo e a pr\u00f3pria rua \u00e9 o caminho entre esses n\u00f3s, e tem rela\u00e7\u00e3o com os outros n\u00f3es pelas ruas. O maps ent\u00e3o relcionando com os grafos, ele calcula os n\u00f3s e define o melhor caminho at\u00e9 chegar no n\u00f3 de desejo. Outro conjunto de rela\u00e7\u00f5es que podemos relacionar com grafos s\u00e3o as p\u00e1ginas webs, pensando em um site, que tem acesso a outro, cada um desses hiperlinks \u00e9 um n\u00f3 do grafo que nos leva a outro site. Outro exemplo muito legal s\u00e3o circuitos el\u00e9tricos, com os pontos de conex\u00e3o sendo n\u00f3s do nosso grafo, e os fios os caminhos que nos levam aos outros n\u00f3s. Outro caso legal seria o exemplo de rede de computadores, por exemplo, na RNP (Rede nacional de pesquisa), toda vez no esquema que vemos a sigla de um estado em um roteador temos um ponto de rede para se comunicar com outra faculdade de outro estado, cada um dessas siglas representa um n\u00f3 de rede nos estado, e a linha que os liga \u00e9 o caminho de n\u00f3 a n\u00f3, o interessante desse exemplo \u00e9 que por exemplo imagine que caia uma rota DF para SP, o grafo busca outro caminho sem ser o direto entre esses dois estados, fazendo assim, n\u00e3o dependente de uma \u00fanica rota.</p>"},{"location":"Prova_2/Grafos_1/#o-que-e-um-grafo","title":"O que \u00e9 um grafo?","text":"<p>Um conjunto de v\u00e9rtices, e um conjunto de arestas (conectam pares distindos de v\u00e9rtices), os v\u00e9rtices s\u00e3o numerados de 0 a v-1, representamso os grafos com bolinhas ligadas por linhas que conectam os mesmos (Como estamos em um teclado de computador, indicaremos sem as bolinhas). </p> <p>Grafo 1: Exemplo (4 v\u00e9rtices de 0 at\u00e9 3)</p> <p>Fonte - Autoral</p>"},{"location":"Prova_2/Grafos_1/#algumas-regras-e-conceitos-fundamentais","title":"Algumas regras e conceitos fundamentais:","text":"<ul> <li>N\u00e3o temos uma aresta que sai dela e vai para ela mesma; </li> <li>Dois v\u00e9rtices s\u00e3o adjacentes entre eles, se eles se conectam por meio de uma aresta em comum; </li> <li>Se uma aresta sai por exemplo do n\u00f3 0 para o n\u00f3 2, o caminho \u00e9 de duas vias, ou seja, do 2 eu consigo ir para o 0; </li> <li>Essa \"via de m\u00e3o dupla\" pode ser interrompida em grafos que chamamos de grafos dirigidos, com uma seta no final da aresta temos a indica\u00e7\u00e3o de um caminho s\u00f3 de ida entre um n\u00f3 e outro (veja o grafo 2 abaixo); </li> </ul> <p>Grafo 2: Grafo dirigido</p> <p>Fonte - Autoral</p> <ul> <li>Um grafo com V v\u00e9rtices tem no m\u00e1ximo [v.(v-1)]/2 arestas</li> <li>Grafo completo: Todos os v\u00e9rtices se conectam com todos os v\u00e9rtices:</li> </ul> <p>Grafo 3: Grafo completo</p> <p>Fonte - Autoral</p> <ul> <li>Caminho no grafo: \u00c9 uma sequ\u00eancia de v\u00e9rtices em que cada v\u00e9rtice sucessivo \u00e9 adjacente ao predecessor do caminho, <ul> <li>Caminho simples temos v\u00e9rtices e arestas distintas.</li> <li>Um ciclo: \u00c9 um caminho que \u00e9 simples exceto pelo primeiro e \u00faltimo v\u00e9rtice que s\u00e3o os mesmos, veja a imagem abaixo, mostrando isso.</li> </ul> </li> </ul> <p>Grafo 4: Grafo c\u00edclico</p> <p>Fonte - Autoral</p> <ul> <li> <p>Um grafo \u00e9 conexo se h\u00e1 um caminho de cada v\u00e9rtice para todo outro v\u00e9rtice no pr\u00f3prio grafo.</p> <ul> <li>Um grafo conexo exige um caminho para todos os outros v\u00e9rtices enquanto um grafo completo tem que ter uma aresta para todos os outros v\u00e9rtices.</li> <li>Um grafo que n\u00e3o \u00e9 conexo consiste em um conjunto de componentes conexas, que s\u00e3o subgrafos conexos m\u00e1ximos.</li> </ul> </li> <li> <p>Um grafo conexo ac\u00edclico \u00e9 tamb\u00e9m chamado de \u00e1rvore.</p> <ul> <li>Um conjunto de \u00e1rvores \u00e9 chamado de floresta.</li> </ul> </li> <li> <p>Como \u00e9 a nossa ADT dos grafos?</p> </li> </ul> <pre><code>typedef struct {int v; int w;}Edge; // struct respons\u00e1vel por arestas (v e w s\u00e3o os v\u00e9rtices que ela conecta).\nEdge EDGE(int, int); // Chamada de inicializa\u00e7\u00e3o da fun\u00e7\u00e3o EDGE.\ntypedef struct graph *Graph; // strfuct respons\u00e1vel pelos grafos (ainda n\u00e3o definida).\nGraph GRAPHinit(int); // Fun\u00e7\u00e3o de inicializa\u00e7\u00e3o de um grafo, o int \u00e9 a quantidade de v\u00e9rtices.\nvoid GRAPHInsertE(Graph, Edge); // Insere as arestas dentro do grafo.\nvoid GRAPHRemoveE(Graph, Edge); // Remove uma aresta dentro do grafo.\nint GRAPHEdges(Edge[], Graph G); // Contador de arestas.\nGraph GRAPHCopy(Graph); // Me devolve um grafo, duplicando um grafo.\nvoid GRAPHDestroy(Graph); // Dar um free corretamente do grafo livrando espa\u00e7o.\n</code></pre> <ul> <li>Como \u00e9 a cara da minha struct graph?<ul> <li>Uma matriz de adjac\u00eancia.<ul> <li>Uma matriz onde indicamos quem est\u00e1 conectado com quem.</li> </ul> </li> </ul> </li> </ul>"},{"location":"Prova_2/Grafos_1/#matriz-de-adjacencia","title":"Matriz de adjac\u00eancia","text":"<p>Struct graph e a fun\u00e7\u00e3o GRAPHInit (inicia o grafo com os v\u00e9rtices)</p> <pre><code>struct graph{int V, int E; int **adj;} // int V = num_vertices, int E = num_aretas, int **adj = matriz_de_adjagencia inicializada\nGraph GRAPHInit(int v){\n    Graph G = malloc(sizeof(*G));\n    G-&gt;V = v; // Recebe os v\u00e9rtices colocados\n    G-&gt;E = 0; //Ainda sem arestas\n    G-&gt;adj = MATRIZInit(V,V, 0); // Inicializa a matriz de adjac\u00eancia com 0's\n    return G;\n}\n\n</code></pre> <p></p> <p>Fun\u00e7\u00e3o MATRIZInit (inicializa a matriz de adjac\u00eancia)</p> <pre><code>int** MATRIZInit(int linhas, int colunas, int valorInicial) {\n    // Aloca mem\u00f3ria para a matriz\n    int** matriz = (int*)malloc(linhas * sizeof(int));\n    for (int i = 0; i &lt; linhas; i++) {\n        matriz[i] = (int*)malloc(colunas * sizeof(int));\n        // Inicializa a linha com o valor inicial especificado\n        for (int j = 0; j &lt; colunas; j++) {\n            matriz[i][j] = valorInicial;\n        }\n    }\n    return matriz;\n}\n</code></pre> <p>Fun\u00e7\u00e3o GRAPHInsertE (Insere uma aresta no grafo)</p> <pre><code>void GRPAHInsertE(Graph G, Edge e){ // Custo O(1)\n    int v = e.v, w = e.w; // e = struct e v e w os v\u00e9rtices que ela vai atingir\n    if(G-&gt;adj[v][w] == 0)\n        G-&gt;E++;\n    G-&gt;adj[v][w] = 1;\n    G-&gt;adj[w][v] = 1; // Se n\u00e3o for um grafo dirigido ambas atribui\u00e7\u00f5es s\u00e3o verdade\n}\n</code></pre> <p>Fun\u00e7\u00e3o GRAPHRemoveE (Remove uma aresta no grafo)</p> <pre><code>void GRAPHRemoveE(Graph G, Edge e){ // Custo O(1)\n    int v = e.v, w = e.w;\n    if(G-&gt;adj[v][w] == 1)\n        G-&gt;E--;\n    G-&gt;adj[v][w] = 0;\n    G-&gt;adj[w][v] = 0; \n}\n</code></pre> <p>Fun\u00e7\u00e3o GRAPHEdges (Contador de aresta no grafo)</p> <pre><code>int GRAPHEdges(Edge a[], Graph G){ \n    int v, w, E = 0;\n    for(v = 0; v &lt; G-&gt;v; v++)\n        for(w =v+1; w &lt; G-&gt;w; w++) // Por n\u00e3o ser um grafo dirigido n\u00e3o precisamos olhar os v\u00e9rtices menores do que estamos analizando\n            if(G-&gt;adj[v][w] = 1)\n                a[E++] = EDGE(v,w);\n    return E;\n}\n</code></pre> <ul> <li>Quando um v\u00e9rtice se liga a outro, colocamos na matriz de adjac\u00eancia o n\u00famero 1, caso contr\u00e1rio deixamos com 0.</li> <li>Se n\u00e3o for dirigido colocamos de 0 para 5 e de 5 para 0 por exemplo para indicar que podemos fazer o caminho inverso.</li> </ul> <p>Exemplo te matriz adjacente do grafo</p> 0 1 2 3 4 5 6 0 1 1 1 1 1 1 2 1 3 1 1 1 4 1 5 1 1 6 <ul> <li>Al\u00e9m das matrizes de adjac\u00eancias podemos armazenar tamb\u00e9m nas listas de adjac\u00eancias</li> </ul>"},{"location":"Prova_2/Grafos_2/","title":"Grafos","text":""},{"location":"Prova_2/Grafos_2/#lista-de-adjagencias","title":"Lista de adjag\u00eancias","text":"<p>Qualquer opera\u00e7\u00e3o para percorrer os v\u00e9rtices para proucurar as arestas vamos gastar um tempo proporcional a v^2, por isso vamos utilizar as listas adjacentes, por mais que podemos utilizar aquelas t\u00e9cnica de n\u00e3o preecisar olhar os vertices meenores da matriz, ainda temos um tempo n\u00e3o muito agrad\u00e1vel para esse tipo de problema, ainda mais com muitas arestas e v\u00e9rtices. Uma maneira diferente mas que tem sua funcionalidade, ao inv\u00e9s de termos uma matriz teremos como se fosse um grande vetor, e cada \"coisa\" dentro desse vetor seja uma lista encadeada, e quando tiver uam aresta teremos um n\u00f3 sa\u00edndo dessa posi\u00e7\u00e3o do vetor e mostrando ao qual ele est\u00e1 ligado, e se n\u00e3o estivermos falando de um grafo dirigido, o outro tamb\u00e9m ter\u00e1 seu n\u00f3 apontado para ele.</p> <p>Vamos fazer nossas opera\u00e7\u00f5es, s\u00e3o essencialmente as mesmas da matriz de adjac\u00eancia, somente tomando cuidado sabendo que estamos falando de uma fila e n\u00e3o de uma matriz, adicionaremos ent\u00e3o o n\u00f3.</p> <p>Estrutura do n\u00f3 em lista de adjac\u00eancias</p> <pre><code>typedef struct node *link\nstruct node {int v; link next;};\nstruct graph{int V; int E; link *adj;};\nlink NEW(int v; link next){\n    link x = malloc(sizeof *x);  // Cria a aresta\n    if(x == NULL)\n        tela_azul(); // N\u00e3o encontrou , ou n\u00e3o foi criado nenhuma estrutura\n    x-&gt;v = v;   // Adiciona na struct o v\n    x-&gt;next = next; // Coloca o link para a pr\u00f3xima dentro da struct\n    return x;\n}\n\ngraph GRAPHInit(int V){  // Cria o grafo\n    int v;\n    Graph G = malloc(sizeof *G);    // Aloca a quantidade de espa\u00e7o para os v\u00e9rtices\n    G-&gt;v = V;   // Recebe os v\u00e9rtices colocados\n    G-&gt;E = 0;   // Zera as arestas\n    G-&gt;adj = malloc(V*sizeof(link)); // Cria nosso vetor de adjac\u00eancias\n    for(v = 0; v &lt; V; v++)\n        G-&gt;adj[v] = NULL; //  Criamos uma lista de adjac\u00eancias e indicamos que est\u00e3o apontando para NULL, j\u00e1 que n\u00e3o temos arestas no momento.\n    return G;\n}\n\nvoid GRAPHInsert(Graph G, Edge e){  // Insere uma aresta\n    int v = e.v, w = e.w;\n    G-&gt;adj[v] = NEW(w, G-&gt;adj[v]); // Inserimos no in\u00edcio da lista simplesmente por ser mais barato.\n    G-&gt;adj[v] = NEW(v, G-&gt;adj[w]);\n    G-&gt;E++;\n}\n\nint GRAPHEdges(Edge a[], Graph G){ // Salva as arestas em um vetor e retorna a quantidade\n    int v, E=0;                    // Com a chamda a[], se tem que ja foi alocado o vetor do tamanho correto previamente\n    for(v = 0; v &lt; G-&gt;v; v++)\n        for(t = G-&gt;adj[v]; t != NULL; t = t-&gt;next)\n            if(v &lt; t-&gt; v)\n                a[E++] = EDGE(v, t-&gt;v);\n    return E;\n}\n</code></pre>"},{"location":"Prova_2/Grafos_2/#que-metodo-devo-usar","title":"Que m\u00e9todo devo usar?","text":"<p>Compara\u00e7\u00e3o entre vetor de arestas, matriz de adjac\u00eancia e lista de adjac\u00eancia.</p> Vetor de arestas Matriz de adjac\u00eancias Lista de adjac\u00eancias Espa\u00e7o E (quantidade de arestas) V^2 (v\u00e9rtices ao quadrado) V+E Pre\u00e7o para inicializar 1 V^2 V Copiar E V^2 E Destruir 1 V (free em cada v\u00e9rtice) E (Para cada v\u00e9rtice percorre todas as arestas) Inserir arestas 1 1 (L\u00ea o v e o w, e coloca valor 1 na matriz) 1 (Alocar 2 n\u00f3s um para v e um para w, adicionando sempre no in\u00edcio da lista encadeada) Encontrar e remover uma aresta E 1 (Pergunta se v e w \u00e9 1, e se quiser \u00e9 s\u00f3 remover) V (O m\u00e1ximo de arestas que um v\u00e9rtice pode ter \u00e9 exatamente a quantidade de v\u00e9rtices total) V \u00e9 isolado? (Se n\u00e3o tiver nenhuma aresta conectada ao v\u00e9rtice) E (Anda em todas as arestas buscando uma rela\u00e7\u00e3o com outro V) V (percorre toda coluna do v\u00e9rtice para ver se todos os \u00edndices est\u00e3o marcados como 0) 1 (Basta perguntar no \u00edndice para o V se \u00e9 NULL) Caminho de U para V E.log(V) V^2 (Percorrer todas as arestas de U at\u00e9 chegar a v, logo se v\u00ea todas as conex\u00f5es da matriz) V+E"},{"location":"Prova_2/Grafos_2/#busca-em-profundidade-dfs","title":"Busca em profundidade (DFS)","text":"<p>Se eu quero passar por todos os v\u00e9rtices passando pleo menor caminho poss\u00edvel, como posso fazer isso? A busca em profundidade \u00e9 um \u00f3tima tentativa para achar labirintos. Imagine um corredor com 3 sa\u00eddas vamos tomar uma decis\u00e3o de onde ir, para isso vamos usar as pilhas.</p> <p>Busca em profundidade</p> <pre><code>int pre[V];\n\nvoid dfsR(Graph G, Edge e){\n    int t, w = e.w; \n    pre[w]=count++; // Mant\u00e9m a ordem de qual visitamos primeiro, e mostra quais v\u00e9rtices j\u00e1 foram visitados.\n    for(t = 0; t &lt; G-&gt;V, t++)\n        if(G-&gt;adj[w][t] != 0)\n            if(pre[t] == -1) // Para quando todos estiverem com valor diferente de -1, ou a fun\u00e7\u00e3o acaba e passamos por todos os v\u00e9rtices conexos por w\n                dfsR(G, EDGE(w, t));\n}\n\nint main(){\n    GRAPHInit(V);\n    for(int V = 0; V &lt; G-&gt;V; V++)\n        pre[v] = -1;\n    dfsR(G, EDGE(0, 0));\n}\n</code></pre> <p></p> <p>Se fizermos algo parecido com o c\u00f3digo de cima no grafo de baixo, come\u00e7ando do dfsR(G, EDGE(0,0)), ele percorrer\u00e1 todos de 0 at\u00e9 0 passando por todos os caminhos, mas perceba que nenhuma aresta passa pelo 0 e qualquer outro v\u00e9rtice e chega em 8 ou 9, logo ele n\u00e3o perocrrer\u00e1 em momento nenhum esses v\u00e9rtices.</p> <p>Se diferentemente executarmos a fun\u00e7\u00e3o dfsR(G, EDGE(8,8)), ele executar\u00e1 somente um caminho de 8-&gt;9, tendo em vista que s\u00f3 tem esse caminho, e n\u00f3s nesse modelo s\u00f3 contabilizamos a ida, j\u00e1 que a ida e a vinda \u00e9 a mesma aresta.</p> <p>Grafo 5: Grafo exemplo</p> <p>Fonte - Autoral</p>"},{"location":"Prova_2/Grafos_3/","title":"Grafos","text":""},{"location":"Prova_2/Grafos_3/#resumo-de-grafos","title":"Resumo de grafos","text":"<p>O importante \u00e9 definir a rela\u00e7\u00e3o entre os n\u00f3s, ent\u00e3o temos um conjunto de v\u00e9rtices que t\u00eam rela\u00e7\u00e3o com outro conjunto de v\u00e9rtices, tudo o que implementamos \u00e9 para fazer perguntas de como essas rela\u00e7\u00f5es se comportam ou se relacionam, essa conex\u00e3o se da por meio de arestas. Por mais que a estrutura gr\u00e1fica dos grafos seja simples com as bolinhas representando os v\u00e9rtices, e as linhas representando as arestas, quando tratamos essa estrutura na an\u00e1lise de dados essa estrutura j\u00e1 n\u00e3o \u00e9 mais t\u00e3o simples quanto aparenta ser.</p> <p>Podemos representar o grafo de duas formas:</p> <ul> <li>Matriz de adjac\u00eancia: N\u00famero 1 quando tem rela\u00e7\u00e3o e 0 quando n\u00e3o tem rela\u00e7\u00e3o;</li> <li>Lista de adjac\u00eancia: Colocamos no \u00edndice do vetor um link para os outros v\u00e9rtices com que eles est\u00e3o ligados pela arestas;</li> </ul>"},{"location":"Prova_2/Grafos_3/#componentes-conexas","title":"Componentes conexas","text":"<p>Como podemos identificar as componentes conexas usando busca em profundidade? Bem, para isso vamos pegar como exemplo o grafo abaixo j\u00e1 msotrado na aula passada, veja abaixo:</p> <p>Grafo 5: Grafo exemplo</p> <p>Fonte - Autoral</p> <p>Como podemos ver no grafo acima temos duas componentes conexas: Todo grupo unido com o 0 de um lado, e do outro o 9 junto do 8. Como podemos fazer isso? Bom mas antes de fazer isso vamos fazer uma fun\u00e7\u00e3o gen\u00e9rica para fazer uma busca geral no gr\u00e1fico, contando quantos v\u00e9rtices eu visitei</p> <p>Fun\u00e7\u00e3o GRAPHSearch para matriz de adjac\u00eancias</p> <pre><code>static int count, pre[maxV];\nvoid GRAPHSearch(Graph G){  // Com esse algoritmo o sistema computa a sa\u00edda da componente conexa e vai para a pr\u00f3xima\n    int v; // V\u00e9rtices que vou visitar\n    int conexos = 0;\n    count = 0;\n    for(v = 0; G-&gt;V; v++)\n        pre[v]=-1;\n    for(v = 0; G-&gt;V; v++){ // Executa todos de 0 a 7, na segunda intera\u00e7\u00e3o ele faz a intera\u00e7\u00e3o de 8 e 9\n        if(pre[v] == -1){ // Se for != de -1 ele nem entra na DSF\n            dsfR(G, EDGE(v, v));\n            conexos++;\n        }\n    }\n}\n</code></pre> <p>Fun\u00e7\u00e3o GRAPHSearch para lista de adjac\u00eancias</p> <pre><code>void dfsR(Graph G, Edge e){\n    int t, w = e.w;\n    link l;\n    pre[w] = count++;\n    for(l=G-&gt;adj[w]; l != NULL; l = l-&gt;next){\n        t = l-&gt;v;\n        if(pre[t] == -1)    \n            dfsR(G, EDGE(w, t));\n    }\n}\n</code></pre>"},{"location":"Prova_2/Grafos_3/#execucao","title":"Execu\u00e7\u00e3o","text":"<p>Feita no caderno.</p>"},{"location":"Prova_2/Grafos_4/","title":"Grafos","text":""},{"location":"Prova_2/Grafos_4/#busca-em-largura-bfs","title":"Busca em largura (BFS)","text":"<p>O BFS \u00e9 prefer\u00edvel quando se busca encontrar o caminho mais curto entre dois n\u00f3s em um grafo n\u00e3o ponderado (onde todas as arestas t\u00eam o mesmo peso), enquanto o DFS \u00e9 mais eficiente quando se busca explorar um grafo em profundidade, ou quando se deseja encontrar solu\u00e7\u00f5es que podem estar distantes da fonte.</p> <p>Algoritmo da BFS</p> <pre><code>void bfs(Graph G, Edge e){\n    int v, w;\n    Queueput(e);\n    pre[e.w] = count++;\n    while(!Queueempty()){\n        e = Queueget();\n        w = e.w;\n        for(l=G-&gt;adj[w]; l != NULL; l = l-&gt;next){\n            t = l-&gt;v;\n            if(pre[t] == -1){\n                Queueput(EDGE(w, t));\n                pre[t] = count++;\n            }\n        }\n    }\n}\n</code></pre>"}]}